//! Golden file tests comparing jadx-rust output vs Java JADX reference
//!
//! These tests ensure output compatibility with Java JADX.
//! Run with: cargo test -p jadx-cli --test golden_tests
//!
//! Reference files are generated by Java JADX and stored in tests/golden_reference/
//! To regenerate: jadx -d tests/golden_reference/<name> <input_file>

use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Differences we track between Java JADX and Rust JADX
#[derive(Debug, Default)]
struct DiffStats {
    /// Cosmetic differences (whitespace, comments) - acceptable
    cosmetic: usize,
    /// Parameter naming differences
    param_names: usize,
    /// Explicit 'this.' prefix differences
    this_prefix: usize,
    /// Missing features (ternary, etc.)
    missing_features: usize,
    /// Semantic differences - bugs to fix
    semantic: usize,
}

/// Normalize Java code for comparison (ignore cosmetic differences)
fn normalize_java(code: &str) -> String {
    code.lines()
        // Remove blank lines
        .filter(|line| !line.trim().is_empty())
        // Remove single-line comments
        .filter(|line| !line.trim().starts_with("//"))
        // Remove block comment markers
        .filter(|line| {
            let t = line.trim();
            !t.starts_with("/*") && !t.starts_with("*") && !t.ends_with("*/")
        })
        // Normalize indentation
        .map(|line| line.trim().to_string())
        // Remove explicit this. prefix
        .map(|line| line.replace("this.", ""))
        .collect::<Vec<_>>()
        .join("\n")
}

/// Run jadx-rust on a file and return all output files
fn run_rust_jadx(input: &Path) -> Result<HashMap<String, String>, String> {
    let out_dir = tempfile::tempdir().map_err(|e| e.to_string())?;

    let output = Command::new(env!("CARGO_BIN_EXE_jadx-rust"))
        .args(["-d", out_dir.path().to_str().unwrap()])
        .arg(input)
        .output()
        .map_err(|e| e.to_string())?;

    if !output.status.success() {
        return Err(format!(
            "jadx-rust failed: {}",
            String::from_utf8_lossy(&output.stderr)
        ));
    }

    // Collect all Java files
    let mut files = HashMap::new();
    let sources_dir = out_dir.path().join("sources");

    if sources_dir.exists() {
        collect_java_files(&sources_dir, &sources_dir, &mut files)?;
    }

    Ok(files)
}

/// Recursively collect Java files from a directory
fn collect_java_files(
    base: &Path,
    dir: &Path,
    files: &mut HashMap<String, String>,
) -> Result<(), String> {
    for entry in std::fs::read_dir(dir).map_err(|e| e.to_string())? {
        let entry = entry.map_err(|e| e.to_string())?;
        let path = entry.path();

        if path.is_dir() {
            collect_java_files(base, &path, files)?;
        } else if path.extension().map(|e| e == "java").unwrap_or(false) {
            let rel_path = path.strip_prefix(base).unwrap().to_string_lossy().to_string();
            let content = std::fs::read_to_string(&path).map_err(|e| e.to_string())?;
            files.insert(rel_path, content);
        }
    }
    Ok(())
}

/// Load reference files from golden_reference directory
fn load_reference_files(name: &str) -> Result<HashMap<String, String>, String> {
    let ref_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests/golden_reference")
        .join(name)
        .join("sources");

    if !ref_dir.exists() {
        return Err(format!("Reference directory not found: {}", ref_dir.display()));
    }

    let mut files = HashMap::new();
    collect_java_files(&ref_dir, &ref_dir, &mut files)?;
    Ok(files)
}

/// Compare outputs and report differences
fn compare_outputs(
    reference: &HashMap<String, String>,
    actual: &HashMap<String, String>,
    class_filter: Option<&str>,
) -> DiffStats {
    let mut stats = DiffStats::default();

    for (path, ref_content) in reference {
        // Skip framework classes for comparison
        if path.starts_with("android/")
            || path.starts_with("androidx/")
            || path.starts_with("kotlin/")
            || path.contains("/R$")
            || path.ends_with("/R.java")
            || path.ends_with("/BuildConfig.java")
        {
            continue;
        }

        // Apply optional class filter
        if let Some(filter) = class_filter {
            if !path.contains(filter) {
                continue;
            }
        }

        match actual.get(path) {
            Some(act_content) => {
                let norm_ref = normalize_java(ref_content);
                let norm_act = normalize_java(act_content);

                if norm_ref != norm_act {
                    // Categorize differences
                    let ref_lines: Vec<_> = norm_ref.lines().collect();
                    let act_lines: Vec<_> = norm_act.lines().collect();

                    for (i, (r, a)) in ref_lines.iter().zip(act_lines.iter()).enumerate() {
                        if r != a {
                            // Check if it's just parameter naming
                            if looks_like_param_diff(r, a) {
                                stats.param_names += 1;
                            } else if r.replace("this.", "") == a.replace("this.", "") {
                                stats.this_prefix += 1;
                            } else {
                                eprintln!(
                                    "Semantic diff in {} line {}:\n  ref: {}\n  act: {}",
                                    path, i + 1, r, a
                                );
                                stats.semantic += 1;
                            }
                        }
                    }

                    // Line count differences
                    if ref_lines.len() != act_lines.len() {
                        stats.semantic += (ref_lines.len() as isize - act_lines.len() as isize).unsigned_abs();
                    }
                }
            }
            None => {
                eprintln!("Missing file in actual output: {}", path);
                stats.semantic += 1;
            }
        }
    }

    stats
}

/// Check if the difference looks like just parameter naming
fn looks_like_param_diff(line1: &str, line2: &str) -> bool {
    // Simple heuristic: same structure, different identifiers
    let words1: Vec<_> = line1.split_whitespace().collect();
    let words2: Vec<_> = line2.split_whitespace().collect();

    if words1.len() != words2.len() {
        return false;
    }

    let mut diff_count = 0;
    for (w1, w2) in words1.iter().zip(words2.iter()) {
        if w1 != w2 {
            // Check if it's likely a variable name (starts with lowercase, no special chars)
            if w1.chars().next().map(|c| c.is_lowercase()).unwrap_or(false)
                && w2.chars().next().map(|c| c.is_lowercase()).unwrap_or(false)
            {
                diff_count += 1;
            } else {
                return false;
            }
        }
    }

    diff_count > 0 && diff_count <= 3
}

// ============================================================================
// Test file helpers
// ============================================================================

fn find_test_file(name: &str) -> Option<PathBuf> {
    let possible_paths = [
        // Absolute path (most reliable)
        PathBuf::from(format!("/mnt/nvme4tb/jadx-rust/jadx-cli/src/test/resources/samples/{}", name)),
        // Relative from CARGO_MANIFEST_DIR
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join(format!("../../../jadx-cli/src/test/resources/samples/{}", name)),
        // Alternative relative path
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join(format!("../../jadx-cli/src/test/resources/samples/{}", name)),
    ];
    possible_paths.into_iter().find(|p| p.exists())
}

// ============================================================================
// Tests
// ============================================================================

#[test]
fn test_small_apk_structure() {
    let input = match find_test_file("small.apk") {
        Some(p) => p,
        None => {
            eprintln!("Skipping: small.apk not found");
            return;
        }
    };

    let actual = run_rust_jadx(&input).expect("jadx-rust failed");

    // Check that MainActivity was generated
    let main_activity = actual.iter()
        .find(|(k, _)| k.contains("MainActivity.java"))
        .map(|(_, v)| v.as_str());

    assert!(main_activity.is_some(), "MainActivity.java not found in output");

    let content = main_activity.unwrap();

    // Critical semantic checks
    assert!(content.contains("package io.github.skylot.android.smallapp;"),
        "Missing package declaration");
    assert!(content.contains("extends Activity"),
        "Missing extends Activity");
    assert!(content.contains("void onCreate"),
        "Missing onCreate method");
    assert!(content.contains("super.onCreate"),
        "Missing super.onCreate call");
    assert!(content.contains("setContentView"),
        "Missing setContentView call");
    assert!(content.contains("Log.i(\"SmallApp\", \"Hello\")"),
        "Missing Log.i call with inlined arguments");
}

#[test]
fn test_small_apk_vs_reference() {
    let input = match find_test_file("small.apk") {
        Some(p) => p,
        None => {
            eprintln!("Skipping: small.apk not found");
            return;
        }
    };

    let reference = match load_reference_files("small_apk") {
        Ok(r) => r,
        Err(e) => {
            eprintln!("Skipping reference comparison: {}", e);
            return;
        }
    };

    let actual = run_rust_jadx(&input).expect("jadx-rust failed");

    let stats = compare_outputs(&reference, &actual, Some("smallapp"));

    println!("\n=== small.apk Comparison Stats ===");
    println!("Cosmetic differences: {}", stats.cosmetic);
    println!("Parameter naming: {}", stats.param_names);
    println!("this. prefix: {}", stats.this_prefix);
    println!("Missing features: {}", stats.missing_features);
    println!("Semantic differences: {}", stats.semantic);

    // Allow some differences for now, but track them
    // Eventually we want semantic == 0
    assert!(stats.semantic <= 5,
        "Too many semantic differences: {}", stats.semantic);
}

#[test]
fn test_hello_dex() {
    let input = match find_test_file("hello.dex") {
        Some(p) => p,
        None => {
            eprintln!("Skipping: hello.dex not found");
            return;
        }
    };

    let actual = run_rust_jadx(&input).expect("jadx-rust failed");

    // Check HelloWorld class exists
    let hello = actual.iter()
        .find(|(k, _)| k.contains("HelloWorld.java"));

    assert!(hello.is_some(), "HelloWorld.java not found");

    let (_, content) = hello.unwrap();
    assert!(content.contains("main"), "Missing main method");
    assert!(content.contains("String[]") || content.contains("String..."),
        "Missing String[] parameter");
}

#[test]
fn test_expression_inlining() {
    // This test specifically checks that expression inlining works
    let input = match find_test_file("small.apk") {
        Some(p) => p,
        None => {
            eprintln!("Skipping: small.apk not found");
            return;
        }
    };

    let actual = run_rust_jadx(&input).expect("jadx-rust failed");

    let main_activity = actual.iter()
        .find(|(k, _)| k.contains("MainActivity.java"))
        .map(|(_, v)| v.as_str())
        .expect("MainActivity.java not found");

    // Check that Log.i has inlined string arguments, not intermediate variables
    assert!(
        main_activity.contains("Log.i(\"SmallApp\", \"Hello\")"),
        "Expression inlining not working - expected Log.i(\"SmallApp\", \"Hello\")\nActual:\n{}",
        main_activity
    );

    // Should NOT have intermediate variables like:
    // String str = "SmallApp";
    // String str2 = "Hello";
    // Log.i(str, str2);
    let has_intermediate = main_activity.contains("str =")
        && main_activity.contains("Log.i(str");

    assert!(
        !has_intermediate,
        "Expression inlining not working - found intermediate variables"
    );
}
