//! SMAP (Source Map) data model types
//!
//! Cloned from JADX: jadx-plugins/jadx-kotlin-source-debug-extension/src/main/kotlin/jadx/plugins/kotlin/smap/model/SMAP.kt
//!
//! Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
//! Use of this source code is governed by the Apache 2.0 license.
//!
//! SMAP is the Source Map format defined in JSR-045 (Debugging Support for Other Languages).
//! Kotlin uses this to map generated bytecode lines back to original Kotlin source files,
//! which is critical for:
//! - Multifile classes (multiple .kt files compiled into one class)
//! - Inline functions (inlined code maps back to original function)
//! - Lambda source mapping

use std::cmp::max;

/// Strata names used by Kotlin compiler
/// JADX Reference: SMAP.kt:9-10
pub const KOTLIN_STRATA_NAME: &str = "Kotlin";
pub const KOTLIN_DEBUG_STRATA_NAME: &str = "KotlinDebug";

/// SMAP section markers (JSR-045)
/// JADX Reference: SMAP.kt:25-29
pub const FILE_SECTION: &str = "*F";
pub const LINE_SECTION: &str = "*L";
pub const STRATA_SECTION: &str = "*S";
pub const END_SECTION: &str = "*E";

/// Source position in original Kotlin file
/// JADX Reference: SMAP.kt:78
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SourcePosition {
    pub line: i32,
    pub file: String,
    pub path: String,
}

impl SourcePosition {
    pub fn new(line: i32, file: String, path: String) -> Self {
        Self { line, file, path }
    }
}

/// Mapping from a range of destination (bytecode) lines to source lines
/// JADX Reference: SMAP.kt:61-73
#[derive(Debug, Clone)]
pub struct RangeMapping {
    /// Source line number in original file
    pub source: i32,
    /// Destination line number in generated bytecode
    pub dest: i32,
    /// Number of lines in this range
    pub range: i32,
    /// Call site for inline function tracking (KotlinDebug stratum)
    pub call_site: Option<SourcePosition>,
    /// Index of parent FileMapping (for back-reference)
    pub file_index: usize,
}

impl RangeMapping {
    pub fn new(source: i32, dest: i32, range: i32, call_site: Option<SourcePosition>, file_index: usize) -> Self {
        Self {
            source,
            dest,
            range,
            call_site,
            file_index,
        }
    }

    /// Check if destination line is contained in this range
    /// JADX Reference: SMAP.kt:62-63
    pub fn contains(&self, dest_line: i32) -> bool {
        self.dest <= dest_line && dest_line < self.dest + self.range
    }

    /// Check if source line has mapping in this range
    /// JADX Reference: SMAP.kt:65-66
    pub fn has_mapping_for_source(&self, source_line: i32) -> bool {
        self.source <= source_line && source_line < self.source + self.range
    }

    /// Map destination line to source position
    /// JADX Reference: SMAP.kt:68-69
    pub fn map_dest_to_source(&self, dest_line: i32, file_name: &str, file_path: &str) -> SourcePosition {
        SourcePosition::new(
            self.source + (dest_line - self.dest),
            file_name.to_string(),
            file_path.to_string(),
        )
    }

    /// Map source line to destination line
    /// JADX Reference: SMAP.kt:71-72
    pub fn map_source_to_dest(&self, source_line: i32) -> i32 {
        self.dest + (source_line - self.source)
    }

    /// Get the range of destination lines as an iterator
    /// JADX Reference: SMAP.kt:75-76
    pub fn dest_range(&self) -> std::ops::Range<i32> {
        self.dest..self.dest + self.range
    }
}

/// File mapping - maps a source file to its line mappings
/// JADX Reference: SMAP.kt:33-59
#[derive(Debug, Clone)]
pub struct FileMapping {
    /// Source file name (e.g., "MyClass.kt")
    pub name: String,
    /// Full path or clean FQN (e.g., "com/example/MyClass.kt")
    pub path: String,
    /// Line mappings for this file
    pub line_mappings: Vec<RangeMapping>,
    /// Index in parent SMAP (for back-reference in RangeMapping)
    index: usize,
}

impl FileMapping {
    pub fn new(name: String, path: String, index: usize) -> Self {
        Self {
            name,
            path,
            line_mappings: Vec::new(),
            index,
        }
    }

    /// Get source info (file name, path, max line)
    /// JADX Reference: SMAP.kt:36-41
    pub fn to_source_info(&self) -> SourceInfo {
        let lines_in_file = self.line_mappings.iter()
            .fold(0, |result, mapping| max(result, mapping.source + mapping.range - 1));
        SourceInfo {
            source_file_name: Some(self.name.clone()),
            path_or_clean_fqn: self.path.clone(),
            lines_in_file,
        }
    }

    /// Add a new line mapping interval
    /// JADX Reference: SMAP.kt:57-58
    pub fn map_new_interval(
        &mut self,
        source: i32,
        dest: i32,
        range: i32,
        call_site: Option<SourcePosition>,
    ) -> &RangeMapping {
        let mapping = RangeMapping::new(source, dest, range, call_site, self.index);
        self.line_mappings.push(mapping);
        self.line_mappings.last().unwrap()
    }

    /// Map a new line number, reusing existing ranges when possible
    /// JADX Reference: SMAP.kt:43-51
    pub fn map_new_line_number(
        &mut self,
        source: i32,
        current_index: i32,
        call_site: Option<&SourcePosition>,
    ) -> i32 {
        // Try to reuse last or first mapping if compatible
        let can_reuse_last = self.line_mappings.last()
            .map(|m| can_reuse_for(m, source, current_index, call_site))
            .unwrap_or(false);

        let can_reuse_first = if !can_reuse_last {
            self.line_mappings.first()
                .map(|m| can_reuse_for(m, source, current_index, call_site))
                .unwrap_or(false)
        } else {
            false
        };

        if can_reuse_last {
            let mapping = self.line_mappings.last_mut().unwrap();
            mapping.range = max(mapping.range, source - mapping.source + 1);
            return mapping.map_source_to_dest(source);
        }

        if can_reuse_first {
            let mapping = self.line_mappings.first_mut().unwrap();
            mapping.range = max(mapping.range, source - mapping.source + 1);
            return mapping.map_source_to_dest(source);
        }

        // Create new interval
        self.map_new_interval(source, current_index + 1, 1, call_site.cloned());
        self.line_mappings.last().unwrap().map_source_to_dest(source)
    }
}

/// Check if a range mapping can be reused for a new source line
/// JADX Reference: SMAP.kt:54-55
fn can_reuse_for(mapping: &RangeMapping, new_source: i32, global_max_dest: i32, new_call_site: Option<&SourcePosition>) -> bool {
    // Call sites must match
    let call_site_matches = match (&mapping.call_site, new_call_site) {
        (None, None) => true,
        (Some(a), Some(b)) => a == b,
        _ => false,
    };

    if !call_site_matches {
        return false;
    }

    let offset = new_source - mapping.source;
    let in_global_max = mapping.contains(global_max_dest);
    let limit = mapping.range + if in_global_max { 10 } else { 0 };

    offset >= 0 && offset < limit
}

/// Source file information
/// JADX Reference: jadx-plugins/jadx-kotlin-source-debug-extension/src/main/kotlin/jadx/plugins/kotlin/smap/model/SourceInfo.kt
#[derive(Debug, Clone)]
pub struct SourceInfo {
    pub source_file_name: Option<String>,
    pub path_or_clean_fqn: String,
    pub lines_in_file: i32,
}

/// SMAP (Source Map) structure from SourceDebugExtension attribute
/// JADX Reference: SMAP.kt:16-30
#[derive(Debug, Clone)]
pub struct SMAP {
    /// File mappings indexed by file ID
    pub file_mappings: Vec<FileMapping>,
    /// All line mappings sorted by destination line (for binary search)
    intervals: Vec<(usize, usize)>, // (file_index, mapping_index)
}

impl SMAP {
    /// Create new SMAP from file mappings
    /// JADX Reference: SMAP.kt:17-18
    pub fn new(file_mappings: Vec<FileMapping>) -> Self {
        // Build sorted intervals for binary search
        // Collect (file_index, mapping_index, dest) tuples and sort by dest
        let mut intervals: Vec<(usize, usize, i32)> = Vec::new();
        for (file_idx, file_mapping) in file_mappings.iter().enumerate() {
            for (map_idx, mapping) in file_mapping.line_mappings.iter().enumerate() {
                intervals.push((file_idx, map_idx, mapping.dest));
            }
        }
        intervals.sort_by_key(|&(_, _, dest)| dest);

        let intervals: Vec<(usize, usize)> = intervals.into_iter()
            .map(|(file_idx, map_idx, _)| (file_idx, map_idx))
            .collect();

        Self {
            file_mappings,
            intervals,
        }
    }

    /// Find range mapping for a destination line number using binary search
    /// JADX Reference: SMAP.kt:20-23
    pub fn find_range(&self, line_number: i32) -> Option<(&FileMapping, &RangeMapping)> {
        // Binary search for the range containing this line
        let result = self.intervals.binary_search_by(|&(file_idx, map_idx)| {
            let mapping = &self.file_mappings[file_idx].line_mappings[map_idx];
            if mapping.contains(line_number) {
                std::cmp::Ordering::Equal
            } else if mapping.dest > line_number {
                std::cmp::Ordering::Greater
            } else {
                std::cmp::Ordering::Less
            }
        });

        match result {
            Ok(idx) => {
                let (file_idx, map_idx) = self.intervals[idx];
                let file = &self.file_mappings[file_idx];
                let mapping = &file.line_mappings[map_idx];
                Some((file, mapping))
            }
            Err(_) => None,
        }
    }

    /// Get the first file mapping (used for class alias extraction)
    pub fn first_file(&self) -> Option<&FileMapping> {
        self.file_mappings.first()
    }

    /// Check if SMAP is empty
    pub fn is_empty(&self) -> bool {
        self.file_mappings.is_empty()
    }
}

/// Class alias rename result
/// JADX Reference: jadx-plugins/jadx-kotlin-source-debug-extension/src/main/kotlin/jadx/plugins/kotlin/smap/model/ClassAliasRename.kt
#[derive(Debug, Clone)]
pub struct ClassAliasRename {
    pub pkg: String,
    pub name: String,
}

impl ClassAliasRename {
    pub fn new(pkg: String, name: String) -> Self {
        Self { pkg, name }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_range_mapping_contains() {
        let mapping = RangeMapping::new(10, 100, 5, None, 0);
        assert!(mapping.contains(100));
        assert!(mapping.contains(104));
        assert!(!mapping.contains(99));
        assert!(!mapping.contains(105));
    }

    #[test]
    fn test_range_mapping_source_to_dest() {
        let mapping = RangeMapping::new(10, 100, 5, None, 0);
        assert_eq!(mapping.map_source_to_dest(10), 100);
        assert_eq!(mapping.map_source_to_dest(12), 102);
        assert_eq!(mapping.map_source_to_dest(14), 104);
    }

    #[test]
    fn test_range_mapping_dest_to_source() {
        let mapping = RangeMapping::new(10, 100, 5, None, 0);
        let pos = mapping.map_dest_to_source(102, "Test.kt", "com/example/Test.kt");
        assert_eq!(pos.line, 12);
        assert_eq!(pos.file, "Test.kt");
    }

    #[test]
    fn test_file_mapping_new_interval() {
        let mut file = FileMapping::new("Test.kt".to_string(), "com/example/Test.kt".to_string(), 0);
        file.map_new_interval(1, 10, 5, None);
        file.map_new_interval(10, 20, 3, None);

        assert_eq!(file.line_mappings.len(), 2);
        assert_eq!(file.line_mappings[0].source, 1);
        assert_eq!(file.line_mappings[0].dest, 10);
        assert_eq!(file.line_mappings[1].source, 10);
        assert_eq!(file.line_mappings[1].dest, 20);
    }

    #[test]
    fn test_smap_find_range() {
        let mut file = FileMapping::new("Test.kt".to_string(), "com/example/Test.kt".to_string(), 0);
        file.map_new_interval(1, 10, 5, None);
        file.map_new_interval(10, 20, 3, None);

        let smap = SMAP::new(vec![file]);

        // Find in first range
        let result = smap.find_range(12);
        assert!(result.is_some());
        let (file, mapping) = result.unwrap();
        assert_eq!(file.name, "Test.kt");
        assert_eq!(mapping.source, 1);

        // Find in second range
        let result = smap.find_range(21);
        assert!(result.is_some());
        let (_, mapping) = result.unwrap();
        assert_eq!(mapping.source, 10);

        // Not found
        let result = smap.find_range(5);
        assert!(result.is_none());
    }
}
