//! Integration test framework for jadx-rust
//!
//! This module provides utilities to test decompilation end-to-end,
//! similar to Java JADX's IntegrationTest class.
//!
//! Test pattern:
//! 1. Compile Java source to .class using javac
//! 2. Convert .class to .dex using d8
//! 3. Decompile .dex using jadx-rust
//! 4. Assert on decompiled output

use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::fs;

pub struct IntegrationTestHelper {
    temp_dir: PathBuf,
    test_name: String,
}

impl IntegrationTestHelper {
    pub fn new(test_name: &str) -> Self {
        let temp_dir = std::env::temp_dir().join(format!("jadx_rust_test_{}", test_name));
        let _ = fs::remove_dir_all(&temp_dir);
        fs::create_dir_all(&temp_dir).expect("Failed to create temp dir");

        Self {
            temp_dir,
            test_name: test_name.to_string(),
        }
    }

    /// Compile Java source to .class file
    pub fn compile_java(&self, java_source: &str) -> Result<PathBuf, String> {
        // Extract class name from source
        let class_name = extract_class_name(java_source)
            .ok_or("Failed to extract class name")?;

        // Write Java source file
        let java_file = self.temp_dir.join(format!("{}.java", class_name));
        fs::write(&java_file, java_source)
            .map_err(|e| format!("Failed to write Java source: {}", e))?;

        // Compile with javac
        let output = Command::new("javac")
            .arg("-source")
            .arg("11")
            .arg("-target")
            .arg("11")
            .arg(&java_file)
            .current_dir(&self.temp_dir)
            .output()
            .map_err(|e| format!("Failed to run javac: {}", e))?;

        if !output.status.success() {
            return Err(format!(
                "javac failed:\nstdout: {}\nstderr: {}",
                String::from_utf8_lossy(&output.stdout),
                String::from_utf8_lossy(&output.stderr)
            ));
        }

        Ok(self.temp_dir.join(format!("{}.class", class_name)))
    }

    /// Convert .class to .dex using d8
    pub fn class_to_dex(&self, class_file: &Path) -> Result<PathBuf, String> {
        let dex_file = self.temp_dir.join("classes.dex");

        // Try d8 (from Android SDK)
        let d8_result = Command::new("d8")
            .arg("--output")
            .arg(&self.temp_dir)
            .arg(class_file)
            .output();

        if let Ok(output) = d8_result {
            if output.status.success() {
                return Ok(dex_file);
            }
        }

        // Fallback to dx (legacy)
        let dx_result = Command::new("dx")
            .arg("--dex")
            .arg(format!("--output={}", dex_file.display()))
            .arg(class_file)
            .output()
            .map_err(|e| format!("Neither d8 nor dx found: {}", e))?;

        if !dx_result.status.success() {
            return Err(format!(
                "dx failed:\nstdout: {}\nstderr: {}",
                String::from_utf8_lossy(&dx_result.stdout),
                String::from_utf8_lossy(&dx_result.stderr)
            ));
        }

        Ok(dex_file)
    }

    /// Decompile .dex file and return decompiled source code
    pub fn decompile_dex(&self, dex_file: &Path) -> Result<HashMap<String, String>, String> {
        use jadx_dex::DexReader;
        use jadx_ir::builder::IrBuilder;
        use jadx_passes::PassManager;
        use jadx_codegen::CodeGenerator;

        // Read DEX file
        let dex_data = fs::read(dex_file)
            .map_err(|e| format!("Failed to read DEX: {}", e))?;

        let reader = DexReader::from_bytes(0, dex_file.display().to_string(), dex_data)
            .map_err(|e| format!("Failed to parse DEX: {}", e))?;

        // Build IR for all classes
        let mut results = HashMap::new();

        for class_def in reader.classes() {
            let class_def = class_def.map_err(|e| format!("Failed to get class: {}", e))?;

            // Build IR
            let class_data = IrBuilder::build_class(&reader, &class_def)
                .map_err(|e| format!("Failed to build IR: {}", e))?;

            // Run analysis passes
            let pass_manager = PassManager::new();
            let analyzed = pass_manager.run_all(class_data)
                .map_err(|e| format!("Pass failed: {}", e))?;

            // Generate code
            let codegen = CodeGenerator::new(&reader);
            let java_code = codegen.generate_class(&analyzed)
                .map_err(|e| format!("Codegen failed: {}", e))?;

            // Store result
            let class_name = class_def.class_type()
                .map_err(|e| format!("Failed to get class name: {}", e))?;
            results.insert(class_name.to_string(), java_code);
        }

        Ok(results)
    }

    /// Full end-to-end test: compile Java -> DEX -> decompile
    pub fn test_decompilation(&self, java_source: &str) -> Result<String, String> {
        let class_file = self.compile_java(java_source)?;
        let dex_file = self.class_to_dex(&class_file)?;
        let mut results = self.decompile_dex(&dex_file)?;

        // Return the first (and usually only) decompiled class
        results.values()
            .next()
            .cloned()
            .ok_or_else(|| "No decompiled output".to_string())
    }
}

impl Drop for IntegrationTestHelper {
    fn drop(&mut self) {
        // Clean up temp directory
        let _ = fs::remove_dir_all(&self.temp_dir);
    }
}

/// Extract class name from Java source
fn extract_class_name(source: &str) -> Option<String> {
    for line in source.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("public class ") || trimmed.starts_with("class ") {
            let parts: Vec<&str> = trimmed.split_whitespace().collect();
            if let Some(idx) = parts.iter().position(|&s| s == "class") {
                if let Some(name) = parts.get(idx + 1) {
                    return Some(name.trim_end_matches('{').to_string());
                }
            }
        }
    }
    None
}

/// Assertion helpers for decompiled code
pub trait CodeAssertions {
    fn contains(&self, expected: &str) -> &Self;
    fn contains_one(&self, expected: &str) -> &Self;
    fn count_string(&self, expected_count: usize, pattern: &str) -> &Self;
    fn does_not_contain(&self, unexpected: &str) -> &Self;
    fn count_of(&self, pattern: &str) -> usize;
}

impl CodeAssertions for String {
    fn contains(&self, expected: &str) -> &Self {
        assert!(
            self.as_str().contains(expected),
            "Expected code to contain: {}\nActual code:\n{}",
            expected,
            self
        );
        self
    }

    fn contains_one(&self, expected: &str) -> &Self {
        let count = self.count_of(expected);
        assert_eq!(
            count, 1,
            "Expected exactly 1 occurrence of: {}\nFound: {}\nActual code:\n{}",
            expected, count, self
        );
        self
    }

    fn count_string(&self, expected_count: usize, pattern: &str) -> &Self {
        let count = self.count_of(pattern);
        assert_eq!(
            count, expected_count,
            "Expected {} occurrences of: {}\nFound: {}\nActual code:\n{}",
            expected_count, pattern, count, self
        );
        self
    }

    fn does_not_contain(&self, unexpected: &str) -> &Self {
        assert!(
            !self.as_str().contains(unexpected),
            "Expected code NOT to contain: {}\nActual code:\n{}",
            unexpected,
            self
        );
        self
    }

    fn count_of(&self, pattern: &str) -> usize {
        self.matches(pattern).count()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_class_name() {
        assert_eq!(
            extract_class_name("public class TestCls {"),
            Some("TestCls".to_string())
        );
        assert_eq!(
            extract_class_name("class Foo {"),
            Some("Foo".to_string())
        );
    }
}
