//! Variable naming pass
//!
//! This pass assigns meaningful names to variables based on:
//! - Type information (e.g., "s" for String, "i" for int loop counters)
//! - Context (e.g., loop counters, array indices)
//! - SSA versioning (e.g., x1, x2 for different definitions)
//!
//! Based on JADX's variable naming strategy for 1:1 output compatibility.

use std::collections::{HashMap, HashSet, VecDeque};

use dexterity_ir::info::DebugInfo;
use dexterity_ir::types::ArgType;

use crate::ssa::SsaResult;
use crate::type_inference::TypeInferenceResult;

/// Check if a name is a valid Java identifier and printable
/// (like JADX's NameMapper.isValidAndPrintable)
fn is_valid_identifier(name: &str) -> bool {
    if name.is_empty() {
        return false;
    }

    // Check reserved words
    const RESERVED: &[&str] = &[
        "abstract", "assert", "boolean", "break", "byte", "case", "catch",
        "char", "class", "const", "continue", "default", "do", "double",
        "else", "enum", "extends", "false", "final", "finally", "float",
        "for", "goto", "if", "implements", "import", "instanceof", "int",
        "interface", "long", "native", "new", "null", "package", "private",
        "protected", "public", "return", "short", "static", "strictfp",
        "super", "switch", "synchronized", "this", "throw", "throws",
        "transient", "true", "try", "void", "volatile", "while", "_",
    ];

    if RESERVED.contains(&name) {
        return false;
    }

    // Check valid Java identifier
    let mut chars = name.chars();
    if let Some(first) = chars.next() {
        if !first.is_alphabetic() && first != '_' && first != '$' {
            return false;
        }
    }

    for c in chars {
        if !c.is_alphanumeric() && c != '_' && c != '$' {
            return false;
        }
    }

    // Check printable (ASCII 32-126)
    name.chars().all(|c| (32..=126).contains(&(c as u32)))
}

/// Sanitize a name to be a valid Java identifier
/// Converts invalid characters (like hyphens) to valid alternatives
/// Returns None if the name cannot be sanitized (e.g., empty or all invalid)
fn sanitize_identifier(name: &str) -> Option<String> {
    if name.is_empty() {
        return None;
    }

    // Strip Compose compiler SSA markers (e.g., "$i$a$CacheMainActivityKt$Greeting$2$2$139276541")
    // These are generated by Kotlin Compose compiler for inline lambda caching
    let name = if let Some(stripped) = name.strip_prefix("$i$a$") {
        // Extract meaningful part after the SSA marker
        // Pattern: $i$a$<operation>$<class>$<method>$<numbers>$<hash>
        // Try to extract the operation name or fall back to a simplified name
        let parts: Vec<&str> = stripped.split('$').collect();
        if !parts.is_empty() && !parts[0].is_empty() {
            parts[0] // Use first meaningful part (e.g., "Cache" from "CacheMainActivityKt")
        } else {
            // If can't extract meaningful part, use generic name
            "inline"
        }
    } else {
        name
    };

    // If already valid, return as-is
    if is_valid_identifier(name) {
        return Some(name.to_string());
    }

    let mut result = String::with_capacity(name.len());
    let mut chars = name.chars().peekable();
    let mut prev_was_hyphen = false;

    // Handle first character
    if let Some(first) = chars.next() {
        if first.is_alphabetic() || first == '_' || first == '$' {
            result.push(first);
        } else if first == '-' {
            // Skip leading hyphen, capitalize next char
            prev_was_hyphen = true;
        } else if first.is_ascii_digit() {
            // Prefix digit with underscore
            result.push('_');
            result.push(first);
        } else {
            // Skip other invalid start characters
            prev_was_hyphen = true;
        }
    }

    // Handle remaining characters
    for c in chars {
        if c == '-' {
            // Replace hyphen: capitalize next character (camelCase)
            prev_was_hyphen = true;
        } else if c.is_alphanumeric() || c == '_' || c == '$' {
            if prev_was_hyphen && c.is_alphabetic() {
                result.push(c.to_ascii_uppercase());
            } else {
                result.push(c);
            }
            prev_was_hyphen = false;
        }
        // Skip other invalid characters
    }

    // Check if result is valid
    if result.is_empty() {
        return None;
    }

    // Check reserved words - if sanitized name is reserved, prefix with underscore
    const RESERVED: &[&str] = &[
        "abstract", "assert", "boolean", "break", "byte", "case", "catch",
        "char", "class", "const", "continue", "default", "do", "double",
        "else", "enum", "extends", "false", "final", "finally", "float",
        "for", "goto", "if", "implements", "import", "instanceof", "int",
        "interface", "long", "native", "new", "null", "package", "private",
        "protected", "public", "return", "short", "static", "strictfp",
        "super", "switch", "synchronized", "this", "throw", "throws",
        "transient", "true", "try", "void", "volatile", "while", "_",
    ];

    if RESERVED.contains(&result.as_str()) {
        result.insert(0, '_');
    }

    Some(result)
}

/// Get variable name from debug info by register and instruction offset
/// (like JADX's DebugInfoApplyVisitor)
fn get_debug_name(debug_info: Option<&DebugInfo>, reg: u16, insn_offset: u32) -> Option<String> {
    let debug = debug_info?;

    for local_var in &debug.local_vars {
        if local_var.reg == reg
           && local_var.start_addr <= insn_offset
           && insn_offset <= local_var.end_addr
        {
            // Sanitize name to ensure valid Java identifier
            // Handles Kotlin synthetic names with hyphens (e.g., "constructor-impl" -> "constructorImpl")
            return sanitize_identifier(&local_var.name);
        }
    }
    None
}

/// Check if two types are compatible for sharing the same variable name.
/// Types are compatible if they're the same, or one is a supertype/subtype of the other.
/// This is more lenient than Java assignment compatibility to avoid over-splitting.
pub fn types_compatible_for_naming(t1: &ArgType, t2: &ArgType) -> bool {
    // Same type - always compatible
    if t1 == t2 {
        return true;
    }

    // CRITICAL FIX (Dec 2025): Unknown types should be handled more carefully for naming.
    // Previously, Unknown types were compatible with anything, which caused bugs like:
    //   StringBuilder obj6 = new StringBuilder();
    //   obj6 = 1;  // BUG: UnknownNarrow (for int 1) was compatible with Object!
    //
    // For NAMING purposes, we need to be more conservative:
    // - UnknownObject should only be compatible with Objects (not primitives)
    // - UnknownNarrow/UnknownIntegral should only be compatible with narrow types (not Objects)
    // - Unknown/UnknownWide should only be compatible with other Unknown types
    match (t1, t2) {
        // Two unknown types are compatible with each other
        (ArgType::Unknown | ArgType::UnknownNarrow | ArgType::UnknownWide |
         ArgType::UnknownObject | ArgType::UnknownArray | ArgType::UnknownIntegral,
         ArgType::Unknown | ArgType::UnknownNarrow | ArgType::UnknownWide |
         ArgType::UnknownObject | ArgType::UnknownArray | ArgType::UnknownIntegral) => {
            return true;
        }
        // UnknownObject is compatible with Object types (but not primitives)
        (ArgType::UnknownObject, ArgType::Object(_) | ArgType::Array(_) | ArgType::Generic { .. }) |
        (ArgType::Object(_) | ArgType::Array(_) | ArgType::Generic { .. }, ArgType::UnknownObject) => {
            return true;
        }
        // UnknownArray is compatible with Array types
        (ArgType::UnknownArray, ArgType::Array(_)) |
        (ArgType::Array(_), ArgType::UnknownArray) => {
            return true;
        }
        // UnknownNarrow/UnknownIntegral are compatible with narrow primitive types (not objects)
        (ArgType::UnknownNarrow | ArgType::UnknownIntegral,
         ArgType::Boolean | ArgType::Byte | ArgType::Char | ArgType::Short | ArgType::Int) |
        (ArgType::Boolean | ArgType::Byte | ArgType::Char | ArgType::Short | ArgType::Int,
         ArgType::UnknownNarrow | ArgType::UnknownIntegral) => {
            return true;
        }
        // UnknownWide is compatible with wide primitive types (long, double)
        (ArgType::UnknownWide, ArgType::Long | ArgType::Double | ArgType::Float) |
        (ArgType::Long | ArgType::Double | ArgType::Float, ArgType::UnknownWide) => {
            return true;
        }
        // Generic Unknown is NOT compatible with concrete types - be conservative
        // This prevents StringBuilder vs int issues when type inference is incomplete
        (ArgType::Unknown, _) | (_, ArgType::Unknown) => {
            return false;  // Conservative: don't group with concrete types
        }
        _ => {}
    }

    // Primitive types must match exactly (int != boolean, etc.)
    match (t1, t2) {
        (ArgType::Boolean, ArgType::Boolean) |
        (ArgType::Byte, ArgType::Byte) |
        (ArgType::Char, ArgType::Char) |
        (ArgType::Short, ArgType::Short) |
        (ArgType::Int, ArgType::Int) |
        (ArgType::Long, ArgType::Long) |
        (ArgType::Float, ArgType::Float) |
        (ArgType::Double, ArgType::Double) |
        (ArgType::Void, ArgType::Void) => true,

        // Primitives are NOT compatible with each other (int != boolean, etc.)
        (ArgType::Boolean | ArgType::Byte | ArgType::Char | ArgType::Short |
         ArgType::Int | ArgType::Long | ArgType::Float | ArgType::Double | ArgType::Void,
         ArgType::Boolean | ArgType::Byte | ArgType::Char | ArgType::Short |
         ArgType::Int | ArgType::Long | ArgType::Float | ArgType::Double | ArgType::Void) => false,

        // Primitives are NOT compatible with objects
        (ArgType::Boolean | ArgType::Byte | ArgType::Char | ArgType::Short |
         ArgType::Int | ArgType::Long | ArgType::Float | ArgType::Double | ArgType::Void,
         ArgType::Object(_) | ArgType::Array(_) | ArgType::Generic { .. }) |
        (ArgType::Object(_) | ArgType::Array(_) | ArgType::Generic { .. },
         ArgType::Boolean | ArgType::Byte | ArgType::Char | ArgType::Short |
         ArgType::Int | ArgType::Long | ArgType::Float | ArgType::Double | ArgType::Void) => false,

        // FIX (NEW-004): Object types are only compatible if they're the SAME class.
        // Different object types (e.g., String vs AccessibilityNodeInfo) must have separate
        // variable names, even if they're connected through PHI nodes. Otherwise we get:
        //   String source = "BadAccessibility";
        //   source = obj.getSource();  // ERROR: AccessibilityNodeInfo cannot be assigned to String
        (ArgType::Object(name1), ArgType::Object(name2)) => name1 == name2,

        // Arrays are compatible if element types are compatible
        (ArgType::Array(e1), ArgType::Array(e2)) => types_compatible_for_naming(e1, e2),

        // Arrays are NOT compatible with non-array Objects for naming purposes
        // While arrays ARE objects at the JVM level, in Java source code:
        //   String str = readFile();
        //   str = str.split(" ");  // COMPILE ERROR: String[] cannot be assigned to String
        // So Array and Object types must have different variable names.
        (ArgType::Array(_), ArgType::Object(_)) |
        (ArgType::Object(_), ArgType::Array(_)) => false,

        // Generic types - base types must be compatible
        (ArgType::Generic { base: b1, .. }, ArgType::Generic { base: b2, .. }) => {
            b1 == b2 || true  // Generics with same base or different bases can share names
        }
        (ArgType::Generic { .. }, ArgType::Object(_)) |
        (ArgType::Object(_), ArgType::Generic { .. }) => true,

        // Default: incompatible
        _ => false,
    }
}

/// Semantic origin of a variable - used to prevent incompatible groupings
/// even when types match (e.g., array length vs loop counter are both int)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum SemanticOrigin {
    /// From ArrayLength instruction - represents an array bound
    ArrayBound,
    /// From Const 0 or 1 - typically a loop counter initialization
    LoopCounter,
    /// Any other origin
    Other,
}

/// Build a map of semantic origins for all SSA variables.
/// This is used to prevent grouping variables that have the same type but
/// semantically different purposes (e.g., array.length vs loop counter `i = 0`).
///
/// This also propagates origins through PHI nodes. If a PHI has sources with
/// conflicting strong origins (ArrayBound + LoopCounter), the PHI destination
/// is marked as ArrayBound to prevent it from merging with loop counters.
fn build_semantic_origins(ssa: &SsaResult) -> HashMap<(u16, u32), SemanticOrigin> {
    use dexterity_ir::instructions::{InsnType, LiteralArg};

    let mut origins = HashMap::new();

    // Phase 1: Collect origins from instructions
    for block in &ssa.blocks {
        for insn in &block.instructions {
            match &insn.insn_type {
                InsnType::ArrayLength { dest, .. } => {
                    origins.insert((dest.reg_num, dest.ssa_version), SemanticOrigin::ArrayBound);
                }
                InsnType::Const { dest, value } => {
                    // Only Const 0 or 1 are typical loop counter initializations
                    let origin = match value {
                        LiteralArg::Int(v) if *v == 0 || *v == 1 => SemanticOrigin::LoopCounter,
                        _ => SemanticOrigin::Other,
                    };
                    origins.insert((dest.reg_num, dest.ssa_version), origin);
                }
                _ => {}
            }
        }
    }

    // Phase 2: Propagate origins through PHI nodes
    // If a PHI has conflicting origins in its sources (ArrayBound + LoopCounter),
    // mark the PHI dest as ArrayBound to prevent merging with loop counters.
    // This is key to keeping array bounds and loop counters separate.
    for block in &ssa.blocks {
        for phi in &block.phi_nodes {
            let dest = (phi.dest.reg_num, phi.dest.ssa_version);

            // Check if any source is ArrayBound or LoopCounter
            let mut has_array_bound = false;
            let mut has_loop_counter = false;

            for (_, src) in &phi.sources {
                let src_key = (src.reg_num, src.ssa_version);
                match origins.get(&src_key) {
                    Some(SemanticOrigin::ArrayBound) => has_array_bound = true,
                    Some(SemanticOrigin::LoopCounter) => has_loop_counter = true,
                    _ => {}
                }
            }

            // If PHI has conflicting sources, mark dest as ArrayBound
            // (to keep it separate from loop counters)
            if has_array_bound && has_loop_counter {
                origins.insert(dest, SemanticOrigin::ArrayBound);
            } else if has_array_bound {
                // Propagate ArrayBound if only that origin is present
                origins.insert(dest, SemanticOrigin::ArrayBound);
            } else if has_loop_counter {
                // Propagate LoopCounter if only that origin is present
                origins.insert(dest, SemanticOrigin::LoopCounter);
            }
        }
    }

    origins
}

/// Check if two semantic origins are compatible for variable grouping.
/// Array bounds and loop counters should NEVER share the same variable name,
/// even if they're both int and connected via PHI nodes.
fn origins_compatible(o1: SemanticOrigin, o2: SemanticOrigin) -> bool {
    match (o1, o2) {
        (SemanticOrigin::ArrayBound, SemanticOrigin::LoopCounter) => false,
        (SemanticOrigin::LoopCounter, SemanticOrigin::ArrayBound) => false,
        _ => true,
    }
}

/// Build CodeVar groups from SSA result by following PHI node and Move instruction connections.
/// This mirrors JADX's InitCodeVariables.collectConnectedVars() - all SSA variables
/// connected through PHI nodes should share the same name.
///
/// ENHANCED VERSION (Dec 2025 - P2-001 fix):
/// 1. Bidirectional PHI connections: dest <-> all sources
/// 2. PHI source transitivity: all sources that feed the same PHI are connected
/// 3. Move instruction tracking: Move dest <-> src (they represent same logical variable)
///
/// TYPE-AWARE: Variables with incompatible types are NOT grouped together,
/// even if they're PHI/Move connected. This prevents assigning boolean values to int variables.
///
/// SEMANTIC-ORIGIN-AWARE (Dec 2025 - P1-S07 fix): Variables with incompatible semantic
/// origins (ArrayBound vs LoopCounter) are NOT grouped, even if types match.
/// This prevents `length` (array bound) from collapsing with `i` (loop counter).
///
/// Returns a map: (reg, version) -> code_var_index
/// Variables with the same index should get the same name.
fn build_code_vars(ssa: &SsaResult, type_info: &TypeInferenceResult) -> HashMap<(u16, u32), usize> {
    use dexterity_ir::instructions::{InsnType, InsnArg};

    let mut ssa_to_code_var: HashMap<(u16, u32), usize> = HashMap::new();
    let mut next_code_var_idx = 0usize;

    // Pre-compute semantic origins for all variables (P1-S07 fix)
    let semantic_origins = build_semantic_origins(ssa);

    // Build complete adjacency graph from PHI nodes and Move instructions
    let mut connections: HashMap<(u16, u32), HashSet<(u16, u32)>> = HashMap::new();

    // Helper to check type AND semantic origin compatibility
    let check_compatible = |v1: (u16, u32), v2: (u16, u32)| -> bool {
        // Check semantic origins first (P1-S07 fix)
        let o1 = semantic_origins.get(&v1).copied().unwrap_or(SemanticOrigin::Other);
        let o2 = semantic_origins.get(&v2).copied().unwrap_or(SemanticOrigin::Other);
        if !origins_compatible(o1, o2) {
            return false;
        }

        // Then check type compatibility
        let t1 = type_info.types.get(&v1);
        let t2 = type_info.types.get(&v2);
        match (t1, t2) {
            (Some(t1), Some(t2)) => types_compatible_for_naming(t1, t2),
            // CRITICAL FIX (Dec 2025): Be more conservative when type info is missing.
            // Only allow grouping if BOTH types are missing (they might be the same variable).
            // If one has a known type and the other is missing, we can't safely group
            // because the missing one might have an incompatible type (e.g., StringBuilder vs int).
            // This prevents the bug where obj6 is declared as StringBuilder then reassigned to int.
            (None, None) => true,
            _ => false,
        }
    };

    // Helper to add bidirectional connection if types AND semantic origins are compatible
    let mut add_connection = |v1: (u16, u32), v2: (u16, u32), connections: &mut HashMap<(u16, u32), HashSet<(u16, u32)>>| {
        // Check semantic origins first (P1-S07 fix)
        let o1 = semantic_origins.get(&v1).copied().unwrap_or(SemanticOrigin::Other);
        let o2 = semantic_origins.get(&v2).copied().unwrap_or(SemanticOrigin::Other);
        if !origins_compatible(o1, o2) {
            return;
        }

        // Then check type compatibility
        let t1 = type_info.types.get(&v1);
        let t2 = type_info.types.get(&v2);
        let compatible = match (t1, t2) {
            (Some(t1), Some(t2)) => types_compatible_for_naming(t1, t2),
            // CRITICAL FIX (Dec 2025): Same fix as check_compatible above.
            // Only connect if both types are missing. If one is known and one is missing,
            // we can't verify compatibility, so don't create the connection.
            (None, None) => true,
            _ => false,
        };
        if compatible {
            connections.entry(v1).or_default().insert(v2);
            connections.entry(v2).or_default().insert(v1);
        }
    };

    // Phase 1: Build connections from PHI nodes
    for block in &ssa.blocks {
        for phi in &block.phi_nodes {
            let dest = (phi.dest.reg_num, phi.dest.ssa_version);

            // Collect all sources for this PHI
            let sources: Vec<(u16, u32)> = phi.sources.iter()
                .map(|(_, source)| (source.reg_num, source.ssa_version))
                .collect();

            // Connect dest <-> all sources (bidirectional)
            for &src in &sources {
                add_connection(dest, src, &mut connections);
            }

            // Connect all sources to each other (PHI source transitivity)
            // If multiple variables all flow into the same PHI, they're the same logical variable
            // This is key to reducing "SSA version explosion" - variables like i, i2, i3 that
            // all feed the same loop PHI should share one name
            for i in 0..sources.len() {
                for j in (i + 1)..sources.len() {
                    add_connection(sources[i], sources[j], &mut connections);
                }
            }
        }
    }

    // Phase 2: Build connections from Move instructions
    // Move instructions create variable aliases - if we have `v1 = move v0`,
    // then v1 and v0 represent the same logical variable and should share a name
    for block in &ssa.blocks {
        for insn in &block.instructions {
            if let InsnType::Move { dest, src } = &insn.insn_type {
                if let InsnArg::Register(src_reg) = src {
                    let dest_key = (dest.reg_num, dest.ssa_version);
                    let src_key = (src_reg.reg_num, src_reg.ssa_version);
                    add_connection(dest_key, src_key, &mut connections);
                }
            }
        }
    }

    // Phase 3: BFS to find connected components
    // Start from ALL variables that have connections, not just PHI destinations
    let mut visited: HashSet<(u16, u32)> = HashSet::new();
    let mut all_vars: Vec<(u16, u32)> = connections.keys().cloned().collect();
    // CRITICAL: Sort for deterministic ordering across runs
    // HashMap iteration order is randomized, causing non-deterministic variable names
    all_vars.sort();

    for start in all_vars {
        if visited.contains(&start) {
            continue;
        }

        // BFS to find all connected SSA vars with COMPATIBLE types
        let mut connected: Vec<(u16, u32)> = Vec::new();
        let mut queue: VecDeque<(u16, u32)> = VecDeque::new();
        queue.push_back(start);

        while let Some(current) = queue.pop_front() {
            if visited.contains(&current) {
                continue;
            }

            // Double-check type compatibility before adding to group
            let compatible = check_compatible(start, current);

            if !compatible {
                // Don't add to this group - it will get its own group later
                continue;
            }

            visited.insert(current);
            connected.push(current);

            if let Some(neighbors) = connections.get(&current) {
                for neighbor in neighbors {
                    if !visited.contains(neighbor) {
                        queue.push_back(*neighbor);
                    }
                }
            }
        }

        // Assign all connected vars to the same CodeVar index
        if !connected.is_empty() {
            let code_var_idx = next_code_var_idx;
            next_code_var_idx += 1;

            for ssa_var in connected {
                ssa_to_code_var.insert(ssa_var, code_var_idx);
            }
        }
    }

    ssa_to_code_var
}

/// Result of variable naming pass
#[derive(Debug, Clone)]
pub struct VarNamingResult {
    /// Variable names: (reg, ssa_version) -> name
    pub names: HashMap<(u16, u32), String>,
}

/// Method info for variable naming
pub struct MethodNameInfo {
    pub method_name: String,
    pub class_name: String,
}

/// Field info for variable naming (simplified from codegen's FieldInfo)
pub struct FieldNameInfo {
    pub field_name: String,
    pub class_name: String,
}

/// Variable naming context
pub struct VarNaming<'a> {
    /// Used names at each scope level
    used_names: HashSet<String>,
    /// Counter for each base name (to generate unique suffixes)
    name_counters: HashMap<String, u32>,
    /// Parameter register start (parameters already have names)
    #[allow(dead_code)]
    first_param_reg: u16,
    /// Method lookup: method_idx -> (method_name, class_name)
    method_lookup: Option<&'a dyn Fn(u32) -> Option<MethodNameInfo>>,
    /// Type lookup: type_idx -> type_name (internal format like "java/lang/StringBuilder")
    type_lookup: Option<&'a dyn Fn(u32) -> Option<String>>,
    /// Field lookup: field_idx -> (field_name, class_name)
    field_lookup: Option<&'a dyn Fn(u32) -> Option<FieldNameInfo>>,
}

impl<'a> VarNaming<'a> {
    /// Create a new variable naming context
    pub fn new(first_param_reg: u16) -> Self {
        VarNaming {
            used_names: HashSet::new(),
            name_counters: HashMap::new(),
            first_param_reg,
            method_lookup: None,
            type_lookup: None,
            field_lookup: None,
        }
    }

    /// Common root package names that should be reserved to prevent collision with
    /// fully-qualified class names. This matches JADX's behavior.
    const DEFAULT_ROOT_PACKAGES: &'static [&'static str] = &[
        // Java core packages
        "java", "javax",
        // Android packages
        "android", "androidx", "dalvik",
        // Common domain packages
        "com", "org", "net", "io", "edu", "gov", "info", "biz",
        // Kotlin packages
        "kotlin", "kotlinx",
    ];

    /// Create a new variable naming context with lookups
    ///
    /// When `inner_class_names` is provided, those names are pre-reserved to prevent
    /// variable names from colliding with inner class short names. This matches JADX's
    /// NameGen.addNamesUsedInClass() behavior.
    ///
    /// Root package names are also reserved by default to prevent collisions with
    /// fully-qualified class names (like `com.example.Foo`).
    pub fn with_lookups(
        first_param_reg: u16,
        method_lookup: Option<&'a dyn Fn(u32) -> Option<MethodNameInfo>>,
        type_lookup: Option<&'a dyn Fn(u32) -> Option<String>>,
        field_lookup: Option<&'a dyn Fn(u32) -> Option<FieldNameInfo>>,
        inner_class_names: Option<&'a [String]>,
    ) -> Self {
        // Pre-reserve names to prevent collisions (JADX's addNamesUsedInClass behavior)
        let mut used_names = HashSet::new();

        // 1. Reserve root package names to avoid collision with fully-qualified class names
        // e.g., prevent `com` variable from conflicting with `com.example.Foo`
        for &pkg in Self::DEFAULT_ROOT_PACKAGES {
            used_names.insert(pkg.to_string());
        }

        // 2. Reserve inner class short names
        if let Some(names) = inner_class_names {
            for name in names {
                // Reserve both the exact name and lowercase version
                // e.g., if inner class is "Builder", reserve "builder" for variables
                let lowercase = name.chars().next()
                    .map(|c| c.to_lowercase().to_string() + &name[1..])
                    .unwrap_or_default();
                if !lowercase.is_empty() {
                    used_names.insert(lowercase);
                }
            }
        }

        VarNaming {
            used_names,
            name_counters: HashMap::new(),
            first_param_reg,
            method_lookup,
            type_lookup,
            field_lookup,
        }
    }

    /// Generate a unique name based on a base
    fn make_unique(&mut self, base: &str) -> String {
        // If base isn't used, use it directly
        if !self.used_names.contains(base) {
            self.used_names.insert(base.to_string());
            return base.to_string();
        }

        // Otherwise, add a numeric suffix
        let counter = self.name_counters.entry(base.to_string()).or_insert(1);
        loop {
            *counter += 1;
            let name = format!("{}{}", base, counter);
            if !self.used_names.contains(&name) {
                self.used_names.insert(name.clone());
                return name;
            }
        }
    }

    /// Get base name for a type
    fn base_name_for_type(ty: &ArgType) -> &'static str {
        match ty {
            ArgType::Boolean => "z",
            ArgType::Byte => "b",
            ArgType::Char => "c",
            ArgType::Short => "s",
            ArgType::Int => "i",
            ArgType::Long => "l",  // Fixed: was "j", should be "l" for JADX compatibility
            ArgType::Float => "f",
            ArgType::Double => "d",
            ArgType::Object(name) => {
                // JADX OBJ_ALIAS: Exact full-qualified name matching (not contains!)
                // This matches JADX's ApplyVariableNames.OBJ_ALIAS exactly
                // Names come in internal format (java/lang/String), convert to Java format
                let java_name = name.replace('/', ".");

                // Core JADX OBJ_ALIAS mappings - exact matches only
                match java_name.as_str() {
                    "java.lang.String" => "str",
                    "java.lang.Class" => "cls",
                    "java.lang.Throwable" => "th",
                    "java.lang.Object" => "obj",
                    "java.util.Iterator" => "it",
                    "java.util.HashMap" => "map",
                    "java.lang.Boolean" => "bool",
                    "java.lang.Short" => "sh",
                    "java.lang.Integer" => "num",
                    "java.lang.Character" => "ch",
                    "java.lang.Byte" => "b",
                    "java.lang.Float" => "f",
                    "java.lang.Long" => "l",
                    "java.lang.Double" => "d",
                    "java.lang.StringBuilder" => "sb",
                    "java.lang.Exception" => "exc",
                    // Additional common types (exact matches)
                    "java.lang.StringBuffer" => "sb",
                    "java.lang.Number" => "num",
                    "java.math.BigDecimal" => "num",
                    "java.math.BigInteger" => "num",
                    "java.util.List" => "list",
                    "java.util.ArrayList" => "list",
                    "java.util.LinkedList" => "list",
                    "java.util.Map" => "map",
                    "java.util.LinkedHashMap" => "map",
                    "java.util.TreeMap" => "map",
                    "java.util.Set" => "set",
                    "java.util.HashSet" => "set",
                    "java.util.LinkedHashSet" => "set",
                    "java.util.TreeSet" => "set",
                    "java.io.InputStream" => "inputStream",
                    "java.io.OutputStream" => "outputStream",
                    "java.io.Reader" => "reader",
                    "java.io.Writer" => "writer",
                    "java.lang.reflect.Method" => "method",
                    "java.lang.reflect.Field" => "field",
                    "java.lang.reflect.Constructor" => "constructor",
                    "java.util.regex.Pattern" => "pattern",
                    "java.util.regex.Matcher" => "matcher",
                    "java.util.Date" => "date",
                    "java.util.Calendar" => "calendar",
                    "java.nio.ByteBuffer" => "byteBuffer",
                    "java.nio.Buffer" => "buf",
                    // Android common types (exact matches)
                    "android.content.Context" => "context",
                    "android.app.Activity" => "activity",
                    "android.app.Service" => "service",
                    "android.content.Intent" => "intent",
                    "android.os.Bundle" => "bundle",
                    "android.view.View" => "view",
                    "android.os.Handler" => "handler",
                    "java.lang.Runnable" => "runnable",
                    "java.util.concurrent.Callable" => "callable",
                    "java.util.concurrent.Future" => "future",
                    // Not found in OBJ_ALIAS - fall back to class name extraction
                    _ => return Self::extract_class_name_base(name),
                }
            }
            ArgType::Array(elem) => {
                match elem.as_ref() {
                    ArgType::Boolean => "zArr",
                    ArgType::Byte => "bArr",
                    ArgType::Char => "cArr",
                    ArgType::Short => "sArr",
                    ArgType::Int => "iArr",
                    ArgType::Long => "lArr",  // Fixed: was "jArr", should be "lArr"
                    ArgType::Float => "fArr",
                    ArgType::Double => "dArr",
                    ArgType::Object(name) if name.contains("String") => "strArr",
                    ArgType::Object(_) => "objArr",
                    _ => "arr",
                }
            }
            ArgType::Void => "v",
            ArgType::Unknown => "obj",  // Use "obj" for unknown types, not "var"
            _ => "obj",
        }
    }

    /// Extract simple class name and generate base variable name
    /// Examples:
    /// - "android/view/View" → "view"
    /// - "com/example/Outer$Inner" → "inner"
    /// - "java/io/IOException" → "ioException"
    /// - "ABC" (all uppercase) → "abc"
    /// - "AB" (short) → "abVar"
    fn extract_class_name_base(full_name: &str) -> &'static str {
        // Leak the string to get 'static lifetime - variable names are small and cached
        // This is acceptable because we only generate a limited set of base names

        // Extract simple name (after last '/', '$', or '.')
        // Note: Types may be in internal format (/) or Java format (.), and inner classes may use $ or .
        let simple_name = full_name
            .rsplit('/')
            .next()
            .unwrap_or(full_name)
            .rsplit('$')
            .next()
            .unwrap_or(full_name)
            .rsplit('.')
            .next()
            .unwrap_or(full_name);

        // If empty or non-ASCII, fallback to "obj"
        if simple_name.is_empty() || !simple_name.is_ascii() {
            return "obj";
        }

        // Check if name is all digits (anonymous inner class like $1, $2)
        // This catches cases like "MainActivity$1" → "1" which would produce invalid "1Var"
        if simple_name.chars().all(|c| c.is_ascii_digit()) {
            return "anon";
        }

        // Check if all uppercase
        let is_all_uppercase = simple_name.chars().all(|c| !c.is_ascii_lowercase());

        // Generate base name
        let base = if is_all_uppercase {
            // Convert all-uppercase to lowercase
            let lower = simple_name.to_lowercase();
            if lower.len() < 3 {
                // Short names get "Var" suffix
                Box::leak(format!("{}Var", lower).into_boxed_str())
            } else {
                Box::leak(lower.into_boxed_str())
            }
        } else {
            // Lowercase first character
            let mut chars = simple_name.chars();
            if let Some(first) = chars.next() {
                let rest: String = chars.collect();
                let base = format!("{}{}", first.to_lowercase(), rest);

                if base.len() < 3 {
                    // Short names get "Var" suffix
                    Box::leak(format!("{}Var", base).into_boxed_str())
                } else {
                    Box::leak(base.into_boxed_str())
                }
            } else {
                "obj"
            }
        };

        // Final validation - ensure identifier is valid (catches edge cases)
        if !is_valid_identifier(base) {
            return "obj";
        }

        base
    }

    /// Generate a name for a variable based on its type
    pub fn name_for_type(&mut self, ty: &ArgType) -> String {
        let base = Self::base_name_for_type(ty);
        self.make_unique(base)
    }

    /// Mark a name as used (for parameters, etc.)
    pub fn mark_used(&mut self, name: &str) {
        self.used_names.insert(name.to_string());
    }

    /// Try to generate a name from instruction context (like JADX's makeNameFromInsn)
    /// Returns None if no suitable context-based name can be generated
    fn name_from_instruction_context(
        &mut self,
        insn: &dexterity_ir::instructions::InsnNode,
    ) -> Option<String> {
        use dexterity_ir::instructions::{InsnType, CastType};

        match &insn.insn_type {
            // Array length (like JADX's ARRAY_LENGTH case)
            InsnType::ArrayLength { .. } => {
                Some(self.make_unique("length"))
            }

            // String constant - use "str"
            InsnType::ConstString { .. } => {
                Some(self.make_unique("str"))
            }

            // Method invocation - extract name from method name
            // e.g., getUser() -> "user", createBuilder() -> "builder"
            // Special methods like getInstance(), iterator() get specific names
            InsnType::Invoke { method_idx, .. } => {
                if let Some(lookup) = &self.method_lookup {
                    if let Some(info) = lookup(*method_idx) {
                        // First check special method cases (getInstance, iterator, etc.)
                        if let Some(special) = Self::extract_name_from_method_special(&info.method_name, Some(&info.class_name)) {
                            return Some(self.make_unique(&special));
                        }
                        // Then try prefix stripping (getUser -> user, parseXml -> xml)
                        if let Some(base) = Self::extract_name_from_method(&info.method_name) {
                            return Some(self.make_unique(&base));
                        }
                        // Fallback: combine class name + method name (JADX's type+method combination)
                        // e.g., Pattern.compile() -> "patternCompile", Foo.bar() -> "fooBar"
                        if let Some(combined) = Self::make_type_method_name(&info.class_name, &info.method_name) {
                            return Some(self.make_unique(&combined));
                        }
                    }
                }
                None
            }

            // NewInstance - use class name for variable name
            // e.g., new StringBuilder() -> "sb", new MyClass() -> "myClass"
            InsnType::NewInstance { type_idx, .. } => {
                if let Some(lookup) = &self.type_lookup {
                    if let Some(type_name) = lookup(*type_idx) {
                        let base = Self::extract_class_name_base(&type_name);
                        return Some(self.make_unique(base));
                    }
                }
                None
            }

            // Instance field get - use field name for variable name (JADX's IGET case)
            // e.g., obj.buffer -> "buffer2", this.name -> "name2", this.x -> "x2"
            // Note: Add "2" suffix to avoid collision with actual field name
            // (e.g., `int iALPHABET = this.iALPHABET;` becomes `int iALPHABET2 = this.iALPHABET;`)
            InsnType::InstanceGet { field_idx, .. } => {
                if let Some(lookup) = &self.field_lookup {
                    if let Some(info) = lookup(*field_idx) {
                        // Use field name as variable name base with "2" suffix
                        // sanitize_field_name already filters obfuscated short names
                        let base = Self::sanitize_field_name(&info.field_name);
                        if !base.is_empty() {
                            return Some(self.make_unique(&format!("{}2", base)));
                        }
                    }
                }
                None
            }

            // Static field get - use field name for variable name (JADX's SGET case)
            // e.g., Config.DEBUG -> "debug2", System.out -> "out2"
            // Note: Add "2" suffix to avoid collision with actual field name
            InsnType::StaticGet { field_idx, .. } => {
                if let Some(lookup) = &self.field_lookup {
                    if let Some(info) = lookup(*field_idx) {
                        // sanitize_field_name already filters obfuscated short names
                        let base = Self::sanitize_field_name(&info.field_name);
                        if !base.is_empty() {
                            return Some(self.make_unique(&format!("{}2", base)));
                        }
                    }
                }
                None
            }

            // CheckCast - use target type for variable name (JADX's CHECK_CAST case)
            // e.g., (String)obj -> "str", (MyClass)obj -> "myClass"
            InsnType::CheckCast { type_idx, .. } => {
                if let Some(lookup) = &self.type_lookup {
                    if let Some(type_name) = lookup(*type_idx) {
                        let base = Self::extract_class_name_base(&type_name);
                        return Some(self.make_unique(base));
                    }
                }
                None
            }

            // Primitive Cast - use target type for variable name
            // e.g., (long)i -> "l", (int)l -> "i"
            InsnType::Cast { cast_type, .. } => {
                let base = match cast_type {
                    CastType::IntToLong | CastType::FloatToLong | CastType::DoubleToLong => "l",
                    CastType::IntToFloat | CastType::LongToFloat | CastType::DoubleToFloat => "f",
                    CastType::IntToDouble | CastType::LongToDouble | CastType::FloatToDouble => "d",
                    CastType::LongToInt | CastType::FloatToInt | CastType::DoubleToInt => "i",
                    CastType::IntToByte => "b",
                    CastType::IntToChar => "c",
                    CastType::IntToShort => "s",
                };
                Some(self.make_unique(base))
            }

            // NewArray - use "arr" or element type-based name
            InsnType::NewArray { type_idx, .. } => {
                if let Some(lookup) = &self.type_lookup {
                    if let Some(type_name) = lookup(*type_idx) {
                        // Try to get element type from array type name
                        if let Some(base) = Self::array_var_name_from_type(&type_name) {
                            return Some(self.make_unique(base));
                        }
                    }
                }
                Some(self.make_unique("arr"))
            }

            // FilledNewArray - similar to NewArray
            InsnType::FilledNewArray { type_idx, .. } => {
                if let Some(lookup) = &self.type_lookup {
                    if let Some(type_name) = lookup(*type_idx) {
                        if let Some(base) = Self::array_var_name_from_type(&type_name) {
                            return Some(self.make_unique(base));
                        }
                    }
                }
                Some(self.make_unique("arr"))
            }

            // InstanceOf - use boolean-like name
            InsnType::InstanceOf { .. } => {
                Some(self.make_unique("z"))
            }

            // Compare - result is int used for comparison
            InsnType::Compare { .. } => {
                Some(self.make_unique("cmp"))
            }

            // For other instructions, return None to fall back to type-based naming
            _ => None,
        }
    }

    /// Sanitize field name for use as variable name
    /// Handles common field naming patterns and obfuscated names
    fn sanitize_field_name(field_name: &str) -> String {
        // Empty field names are invalid
        if field_name.is_empty() {
            return String::new();
        }

        // Skip very short names (likely obfuscated like "a", "b")
        // Single letters are almost always obfuscation in field names
        if field_name.len() < 2 {
            return String::new();
        }

        // Known meaningful two-char field names that should be allowed
        let meaningful_short = [
            "id", "ID", "Id", "x1", "x2", "y1", "y2",
            "dx", "dy", "dz", "rx", "ry", "rz",
            "cx", "cy", "ax", "ay", "bx", "by",
            "ok", "up", "on", "to", "db", "io",
        ];

        // Skip names that look obfuscated (single lowercase letter + digit like "a1", "b2")
        if field_name.len() == 2 {
            let chars: Vec<char> = field_name.chars().collect();
            // Skip letter+digit patterns unless in meaningful list
            if chars[0].is_ascii_lowercase() && chars[1].is_ascii_digit() {
                if !meaningful_short.contains(&field_name) {
                    return String::new();
                }
            }
            // Skip generic two lowercase letters unless in meaningful list
            if chars[0].is_ascii_lowercase() && chars[1].is_ascii_lowercase() {
                if !meaningful_short.contains(&field_name) {
                    return String::new();
                }
            }
        }

        // Convert to lowercase first char (Java convention for variables)
        let mut chars = field_name.chars();
        let base = if let Some(first) = chars.next() {
            let rest: String = chars.collect();
            format!("{}{}", first.to_lowercase(), rest)
        } else {
            return String::new();
        };

        // Sanitize to handle invalid characters like hyphens
        sanitize_identifier(&base).unwrap_or_default()
    }

    /// Get array variable name from array type
    /// e.g., "[B" -> "bArr", "[Ljava/lang/String;" -> "strArr"
    fn array_var_name_from_type(type_name: &str) -> Option<&'static str> {
        // Type name might be in descriptor format or Java format
        if type_name.starts_with('[') {
            // Descriptor format
            let elem = type_name.trim_start_matches('[');
            return match elem.chars().next()? {
                'B' => Some("bArr"),
                'C' => Some("cArr"),
                'I' => Some("iArr"),
                'J' => Some("lArr"),
                'F' => Some("fArr"),
                'D' => Some("dArr"),
                'Z' => Some("zArr"),
                'S' => Some("sArr"),
                'L' if elem.contains("String") => Some("strArr"),
                _ => Some("arr"),
            };
        }
        // Java format (String[], int[], etc.)
        if type_name.ends_with("[]") {
            let base = type_name.trim_end_matches("[]");
            return match base {
                "byte" => Some("bArr"),
                "char" => Some("cArr"),
                "int" => Some("iArr"),
                "long" => Some("lArr"),
                "float" => Some("fArr"),
                "double" => Some("dArr"),
                "boolean" => Some("zArr"),
                "short" => Some("sArr"),
                "String" => Some("strArr"),
                _ => Some("arr"),
            };
        }
        None
    }

    /// Combine type name and method name as a fallback variable name
    /// e.g., Pattern.compile() -> "patternCompile", Foo.bar() -> "fooBar"
    /// This is used when prefix stripping fails
    fn make_type_method_name(class_name: &str, method_name: &str) -> Option<String> {
        // Skip constructors and special methods
        if method_name.starts_with('<') || method_name.starts_with('$') || method_name.starts_with("access$") {
            return None;
        }

        // Skip very short method names
        if method_name.len() < 3 {
            return None;
        }

        // Get the simple class name (last part after '/', '$', or '.')
        let simple_class = class_name
            .rsplit('/')
            .next()
            .unwrap_or(class_name)
            .rsplit('$')
            .next()
            .unwrap_or(class_name)
            .rsplit('.')
            .next()
            .unwrap_or(class_name);

        // Skip if class name is empty or too short
        if simple_class.is_empty() || simple_class.len() < 2 {
            return None;
        }

        // Convert class name to lowercase start (already should be lowercase via extract_class_name_base style)
        let class_base = Self::extract_class_name_base(class_name);

        // Capitalize first letter of method name
        let mut method_chars = method_name.chars();
        let capitalized_method = if let Some(first) = method_chars.next() {
            format!("{}{}", first.to_uppercase(), method_chars.collect::<String>())
        } else {
            return None;
        };

        // Combine: typeName + CapitalizedMethodName
        let combined = format!("{}{}", class_base, capitalized_method);

        // Validate the combined name isn't too long or problematic
        if combined.len() > 30 {
            return None; // Too long, not helpful
        }

        sanitize_identifier(&combined)
    }

    /// Extract a variable name from a method name by stripping common prefixes
    /// Following JADX's cutPrefix logic in NameGen.java
    fn extract_name_from_method(method_name: &str) -> Option<String> {
        // Skip constructors
        if method_name == "<init>" || method_name == "<clinit>" {
            return None;
        }

        // Comprehensive list of method prefixes (JADX-compatible + extended)
        // Higher priority prefixes first (get/set are most common and reliable)
        let prefixes = [
            // Primary getters/setters (JADX's INVOKE_PREFIXES)
            "get", "set", "put",
            // Boolean getters
            "is", "has", "can", "should", "will", "was", "are", "does",
            // Transformation methods
            "to", "as", "into", "from", "with",
            // Factory methods
            "create", "new", "make", "build", "of", "parse",
            // Data access methods
            "read", "write", "load", "save", "fetch", "find", "lookup",
            // Database/query methods
            "select", "query", "insert", "update", "delete",
            // Processing methods
            "compute", "calculate", "process", "generate", "extract",
            // Action methods
            "execute", "run", "handle", "apply", "perform", "invoke",
            // Configuration methods
            "configure", "setup", "init", "start", "stop",
            // Resource methods
            "open", "close", "connect", "disconnect",
            // Collection methods
            "add", "remove", "contains", "obtain", "acquire",
        ];

        for prefix in prefixes {
            if method_name.starts_with(prefix) && method_name.len() > prefix.len() {
                let rest = &method_name[prefix.len()..];
                let first_char = rest.chars().next();

                // Check if the next character is uppercase (camelCase: getUser)
                // OR underscore followed by uppercase (snake_case: get_User, build_Manufacturer_UC)
                let is_camel_case = first_char.map(|c| c.is_ascii_uppercase()).unwrap_or(false);
                let is_snake_case = first_char == Some('_') && rest.chars().nth(1).map(|c| c.is_ascii_uppercase()).unwrap_or(false);

                if is_camel_case {
                    // camelCase: convert first char to lowercase
                    let mut chars = rest.chars();
                    if let Some(first) = chars.next() {
                        let rest_str: String = chars.collect();
                        let result = format!("{}{}", first.to_lowercase(), rest_str);
                        // Skip very short names
                        if result.len() >= 2 {
                            // Sanitize result (may contain Kotlin synthetic hyphens)
                            return sanitize_identifier(&result);
                        }
                    }
                } else if is_snake_case {
                    // snake_case: skip underscore, use rest as name (e.g., build_Manufacturer_UC -> manufacturer_UC)
                    let name_part = &rest[1..]; // Skip leading underscore
                    if name_part.len() >= 2 {
                        // Convert first char to lowercase
                        let mut chars = name_part.chars();
                        if let Some(first) = chars.next() {
                            let rest_str: String = chars.collect();
                            let result = format!("{}{}", first.to_lowercase(), rest_str);
                            return sanitize_identifier(&result);
                        }
                    }
                }
            }
        }

        // For methods without matching prefix but with clear names, use method name directly
        // This catches methods like "execute()", "run()", "start()" etc.
        // Only use if the name is long enough and descriptive
        if method_name.len() >= 4 && !method_name.starts_with('$') && !method_name.starts_with("access$") {
            // Check it's a valid identifier start
            if method_name.chars().next().map(|c| c.is_ascii_lowercase()).unwrap_or(false) {
                // Don't use method names that start with known prefixes but didn't match above
                // (these are likely single-char results like getX -> x which is too short)
                let has_getter_prefix = method_name.starts_with("get") || method_name.starts_with("set")
                    || method_name.starts_with("is") || method_name.starts_with("has");
                if !has_getter_prefix {
                    // Sanitize method name (may contain Kotlin synthetic hyphens like "constructor-impl")
                    return sanitize_identifier(method_name);
                }
            }
        }

        None
    }

    /// Handle special method names that JADX treats specially
    /// These methods have semantically meaningful return values that deserve specific names
    fn extract_name_from_method_special(method_name: &str, class_name: Option<&str>) -> Option<String> {
        // First check class+method patterns for more semantic names
        if let Some(class) = class_name {
            // Get simple class name (last part after / or .)
            let simple_class = class.rsplit('/').next()
                .unwrap_or(class)
                .rsplit('.')
                .next()
                .unwrap_or(class);

            // Math operations - use descriptive names
            if simple_class == "Math" {
                match method_name {
                    "min" => return Some("min".to_string()),
                    "max" => return Some("max".to_string()),
                    "abs" => return Some("abs".to_string()),
                    "random" => return Some("random".to_string()),
                    "round" => return Some("rounded".to_string()),
                    "floor" => return Some("floored".to_string()),
                    "ceil" => return Some("ceiled".to_string()),
                    "sqrt" => return Some("sqrt".to_string()),
                    "pow" => return Some("power".to_string()),
                    "sin" | "cos" | "tan" => return Some(method_name.to_string()),
                    "log" | "log10" => return Some("log".to_string()),
                    "exp" => return Some("exp".to_string()),
                    _ => {}
                }
            }

            // String operations
            if simple_class == "String" {
                match method_name {
                    "format" => return Some("formatted".to_string()),
                    "valueOf" => return Some("str".to_string()),
                    "substring" => return Some("substring".to_string()),
                    "split" => return Some("parts".to_string()),
                    "trim" => return Some("trimmed".to_string()),
                    "toLowerCase" | "toUpperCase" => return Some("str".to_string()),
                    "replace" | "replaceAll" | "replaceFirst" => return Some("replaced".to_string()),
                    "concat" => return Some("concatenated".to_string()),
                    "join" => return Some("joined".to_string()),
                    _ => {}
                }
            }

            // Collection utility operations
            if simple_class == "Arrays" {
                match method_name {
                    "asList" => return Some("list".to_string()),
                    "copyOf" | "copyOfRange" => return Some("copy".to_string()),
                    "sort" => return Some("sorted".to_string()),
                    "binarySearch" => return Some("index".to_string()),
                    "fill" => return Some("filled".to_string()),
                    "toString" => return Some("str".to_string()),
                    _ => {}
                }
            }

            if simple_class == "Collections" {
                match method_name {
                    "emptyList" | "emptySet" | "emptyMap" => return Some(method_name.to_string()),
                    "singletonList" | "singleton" => return Some("singleton".to_string()),
                    "unmodifiableList" | "unmodifiableSet" | "unmodifiableMap" => {
                        return Some("unmodifiable".to_string());
                    }
                    "synchronizedList" | "synchronizedSet" | "synchronizedMap" => {
                        return Some("synchronized".to_string());
                    }
                    "sort" => return Some("sorted".to_string()),
                    "reverse" => return Some("reversed".to_string()),
                    "shuffle" => return Some("shuffled".to_string()),
                    "max" => return Some("max".to_string()),
                    "min" => return Some("min".to_string()),
                    _ => {}
                }
            }

            // I/O patterns
            if simple_class == "InputStream" || simple_class == "FileInputStream"
                || simple_class == "BufferedInputStream" || simple_class == "DataInputStream" {
                match method_name {
                    "read" => return Some("bytesRead".to_string()),
                    "available" => return Some("available".to_string()),
                    "skip" => return Some("skipped".to_string()),
                    _ => {}
                }
            }

            if simple_class == "Reader" || simple_class == "BufferedReader"
                || simple_class == "InputStreamReader" || simple_class == "FileReader" {
                match method_name {
                    "read" => return Some("charsRead".to_string()),
                    "readLine" => return Some("line".to_string()),
                    _ => {}
                }
            }

            if simple_class == "Scanner" {
                match method_name {
                    "nextLine" => return Some("line".to_string()),
                    "nextInt" => return Some("num".to_string()),
                    "nextLong" => return Some("num".to_string()),
                    "nextDouble" => return Some("num".to_string()),
                    "next" => return Some("token".to_string()),
                    "hasNext" | "hasNextLine" | "hasNextInt" => return Some("hasMore".to_string()),
                    _ => {}
                }
            }

            // System operations
            if simple_class == "System" {
                match method_name {
                    "currentTimeMillis" | "nanoTime" => return Some("time".to_string()),
                    "getProperty" => return Some("property".to_string()),
                    "getenv" => return Some("env".to_string()),
                    "identityHashCode" => return Some("hashCode".to_string()),
                    _ => {}
                }
            }

            // Object operations
            if simple_class == "Objects" {
                match method_name {
                    "requireNonNull" => return Some("nonNull".to_string()),
                    "hash" | "hashCode" => return Some("hash".to_string()),
                    "equals" => return Some("equals".to_string()),
                    "toString" => return Some("str".to_string()),
                    "isNull" | "nonNull" => return Some("isNull".to_string()),
                    _ => {}
                }
            }

            // Optional operations
            if simple_class == "Optional" || simple_class == "OptionalInt"
                || simple_class == "OptionalLong" || simple_class == "OptionalDouble" {
                match method_name {
                    "of" | "ofNullable" => return Some("optional".to_string()),
                    "empty" => return Some("empty".to_string()),
                    "get" | "orElse" | "orElseGet" => return Some("value".to_string()),
                    "isPresent" | "isEmpty" => return Some("present".to_string()),
                    "map" | "flatMap" => return Some("mapped".to_string()),
                    "filter" => return Some("filtered".to_string()),
                    _ => {}
                }
            }

            // Pattern/Matcher operations
            if simple_class == "Pattern" {
                match method_name {
                    "compile" => return Some("pattern".to_string()),
                    "matcher" => return Some("matcher".to_string()),
                    "matches" => return Some("matches".to_string()),
                    "split" => return Some("parts".to_string()),
                    _ => {}
                }
            }

            if simple_class == "Matcher" {
                match method_name {
                    "find" | "matches" | "lookingAt" => return Some("found".to_string()),
                    "group" => return Some("group".to_string()),
                    "start" | "end" => return Some("pos".to_string()),
                    "replaceAll" | "replaceFirst" => return Some("replaced".to_string()),
                    _ => {}
                }
            }

            // Integer/Long parse operations
            if simple_class == "Integer" || simple_class == "Long" || simple_class == "Short"
                || simple_class == "Byte" || simple_class == "Float" || simple_class == "Double" {
                match method_name {
                    "parseInt" | "parseLong" | "parseShort" | "parseByte"
                    | "parseFloat" | "parseDouble" => return Some("parsed".to_string()),
                    "valueOf" => return Some("num".to_string()),
                    "decode" => return Some("decoded".to_string()),
                    "toHexString" | "toBinaryString" | "toOctalString" => return Some("str".to_string()),
                    "intValue" | "longValue" | "floatValue" | "doubleValue" => {
                        return Some("value".to_string());
                    }
                    _ => {}
                }
            }

            // UUID
            if simple_class == "UUID" {
                match method_name {
                    "randomUUID" => return Some("uuid".to_string()),
                    "fromString" => return Some("uuid".to_string()),
                    _ => {}
                }
            }

            // Date/Time operations
            if simple_class == "Date" || simple_class == "Calendar" || simple_class == "Instant"
                || simple_class == "LocalDate" || simple_class == "LocalDateTime" || simple_class == "LocalTime" {
                match method_name {
                    "now" | "getTime" | "getInstance" => return Some("time".to_string()),
                    "parse" => return Some("date".to_string()),
                    "format" => return Some("formatted".to_string()),
                    _ => {}
                }
            }

            // StringBuilder/StringBuffer
            if simple_class == "StringBuilder" || simple_class == "StringBuffer" {
                if method_name == "toString" {
                    return Some("str".to_string());
                }
            }

            // List/Collection operations
            if simple_class.contains("List") || simple_class.contains("Set") || simple_class.contains("Collection") {
                match method_name {
                    "get" => return Some("item".to_string()),
                    "toArray" => return Some("array".to_string()),
                    "subList" => return Some("subList".to_string()),
                    "stream" => return Some("stream".to_string()),
                    _ => {}
                }
            }

            // Map operations
            if simple_class.contains("Map") {
                match method_name {
                    "get" => return Some("value".to_string()),
                    "getOrDefault" => return Some("value".to_string()),
                    "keySet" => return Some("keys".to_string()),
                    "values" => return Some("values".to_string()),
                    "entrySet" => return Some("entries".to_string()),
                    _ => {}
                }
            }
        }

        // Then check method-only patterns
        match method_name {
            // Factory methods - use declaring class name
            // e.g., Cipher.getInstance() -> "cipher", KeyFactory.getInstance() -> "keyFactory"
            "getInstance" | "newInstance" => {
                class_name.map(|c| Self::extract_class_name_base(c).to_string())
            }
            // Iterator methods - always use "it"
            "iterator" | "listIterator" | "descendingIterator" | "spliterator" => {
                Some("it".to_string())
            }
            // Class/type methods
            "forName" | "getClass" | "getComponentType" | "getSuperclass" => {
                Some("cls".to_string())
            }
            // toString: JADX returns the declaring class name, not "str"
            // e.g., Pattern.toString() -> "pattern", not "str"
            "toString" => {
                class_name.map(|c| Self::extract_class_name_base(c).to_string())
            }
            // valueOf still returns "str" for String.valueOf() etc.
            "valueOf" => Some("str".to_string()),
            // JADX GOOD_VAR_NAMES - use these method names directly as variable names
            // These are common, descriptive names that don't need prefix stripping
            "size" => Some("size".to_string()),
            "length" => Some("length".to_string()),
            "list" => Some("list".to_string()),
            "map" => Some("map".to_string()),
            "next" => Some("next".to_string()),
            // Additional common getters with well-known names
            "previous" => Some("prev".to_string()),
            "current" => Some("current".to_string()),
            "key" => Some("key".to_string()),
            "value" | "getValue" => Some("value".to_string()),
            "getKey" => Some("key".to_string()),
            "entrySet" => Some("entries".to_string()),
            "keySet" => Some("keys".to_string()),
            "values" => Some("values".to_string()),
            // Stream operations
            "stream" | "parallelStream" => Some("stream".to_string()),
            "collect" => Some("collected".to_string()),
            "filter" => Some("filtered".to_string()),
            // Note: "map" already covered above (returns "map")
            "flatMap" => Some("flatMapped".to_string()),
            "reduce" => Some("reduced".to_string()),
            "findFirst" | "findAny" => Some("found".to_string()),
            "count" => Some("count".to_string()),
            "sum" => Some("sum".to_string()),
            "average" => Some("avg".to_string()),
            "min" => Some("min".to_string()),
            "max" => Some("max".to_string()),
            "toList" | "toSet" => Some("result".to_string()),
            // Common Rx/async patterns
            "subscribe" => Some("disposable".to_string()),
            "observe" | "observeOn" | "subscribeOn" => Some("observable".to_string()),
            // Common builder/factory patterns
            "build" | "create" => {
                class_name.map(|c| Self::extract_class_name_base(c).to_string())
            }
            "builder" => Some("builder".to_string()),
            _ => None,
        }
    }

    /// Sanitize a name before using it as a variable name
    /// Public wrapper for use in other modules
    pub fn sanitize_name(name: &str) -> Option<String> {
        sanitize_identifier(name)
    }
}

/// Assign names to all variables in an SSA result (without lookups)
pub fn assign_var_names(
    ssa: &SsaResult,
    type_info: &TypeInferenceResult,
    first_param_reg: u16,
    num_params: u16,
) -> VarNamingResult {
    assign_var_names_with_lookups(ssa, type_info, first_param_reg, num_params, true, None, None, None, None, None, None)
}

/// Assign names to all variables in an SSA result with optional method/type/field lookups
pub fn assign_var_names_with_lookups<'a>(
    ssa: &SsaResult,
    type_info: &TypeInferenceResult,
    first_param_reg: u16,
    num_params: u16,
    is_static: bool,
    param_names: Option<&[String]>,
    method_lookup: Option<&'a dyn Fn(u32) -> Option<MethodNameInfo>>,
    type_lookup: Option<&'a dyn Fn(u32) -> Option<String>>,
    field_lookup: Option<&'a dyn Fn(u32) -> Option<FieldNameInfo>>,
    debug_info: Option<&'a DebugInfo>,
    inner_class_names: Option<&'a [String]>,
) -> VarNamingResult {
    let mut naming = VarNaming::with_lookups(first_param_reg, method_lookup, type_lookup, field_lookup, inner_class_names);

    // Estimate capacity based on SSA result size
    let estimated_vars = ssa.blocks.iter()
        .map(|b| b.instructions.len() + b.phi_nodes.len())
        .sum::<usize>();

    let mut names = HashMap::with_capacity(estimated_vars);

    // Reserve actual parameter names (they're already set up in method signature)
    if let Some(names_slice) = param_names {
        for name in names_slice {
            naming.mark_used(name);
        }
    } else {
        // Fallback: reserve placeholder names for backward compatibility
        for i in 0..num_params {
            let name = format!("p{}", i);
            naming.mark_used(&name);
        }
    }

    // Reserve inner class short names to prevent variable-inner class collisions
    // (like JADX's NameGen.addNamesUsedInClass())
    if let Some(inner_names) = inner_class_names {
        for name in inner_names {
            naming.mark_used(name);
        }
    }

    // Build CodeVar groups from PHI nodes (like JADX's InitCodeVariables)
    // Variables connected through PHI nodes should share the same name
    // TYPE-AWARE: Variables with incompatible types get separate names
    let code_var_map = build_code_vars(ssa, type_info);
    let mut code_var_names: HashMap<usize, String> = HashMap::new();

    // Build assignment map: (reg, version) -> (block_idx, insn_idx, insn_offset)
    // (like JADX's SSAVar.getAssignInsn())
    // Also stores instruction offset for debug info lookup
    let mut assignment_map: HashMap<(u16, u32), (usize, usize, u32)> = HashMap::with_capacity(estimated_vars);
    for (block_idx, block) in ssa.blocks.iter().enumerate() {
        for (insn_idx, insn) in block.instructions.iter().enumerate() {
            if let Some((reg, version)) = get_insn_dest(&insn.insn_type) {
                assignment_map.insert((reg, version), (block_idx, insn_idx, insn.offset));
            }
        }
    }

    // Collect all (reg, version) pairs that need names
    let mut vars_to_name: Vec<(u16, u32)> = Vec::with_capacity(estimated_vars);

    for block in &ssa.blocks {
        // Add phi node destinations
        for phi in &block.phi_nodes {
            if phi.dest.reg_num < first_param_reg {
                vars_to_name.push((phi.dest.reg_num, phi.dest.ssa_version));
            }
        }

        // Add instruction destinations
        for insn in &block.instructions {
            if let Some(dest) = get_insn_dest(&insn.insn_type) {
                if dest.0 < first_param_reg {
                    vars_to_name.push(dest);
                }
            }
        }
    }

    // Sort and deduplicate
    vars_to_name.sort();
    vars_to_name.dedup();

    // Build reverse map: code_var_idx -> list of (reg, version)
    let mut code_var_members: HashMap<usize, Vec<(u16, u32)>> = HashMap::new();
    for &(reg, version) in &vars_to_name {
        if let Some(&code_var_idx) = code_var_map.get(&(reg, version)) {
            code_var_members.entry(code_var_idx).or_default().push((reg, version));
        }
    }

    // Helper closure to get potential BASE name and its score for a variable
    // IMPORTANT: This returns the BASE name (e.g., "i", "str") without making it unique.
    // The caller must call make_unique() once on the final selected name.
    // This prevents multiple calls to make_unique when evaluating PHI group candidates,
    // which was causing names like i2, i3, i4 when i, i, i should merge to just "i".
    let get_name_candidate_base = |reg: u16, version: u32, ssa: &SsaResult, assignment_map: &HashMap<(u16, u32), (usize, usize, u32)>| -> Option<(String, u32)> {
        let insn_offset = assignment_map.get(&(reg, version)).map(|&(_, _, off)| off).unwrap_or(0);

        // Priority 1: Debug info name (score 100)
        if let Some(debug_name) = get_debug_name(debug_info, reg, insn_offset) {
            return Some((debug_name, 100));
        }

        // Priority 2: Context-based name from assignment instruction (score 80)
        if let Some(&(block_idx, insn_idx, _)) = assignment_map.get(&(reg, version)) {
            let block = &ssa.blocks[block_idx];
            let insn = &block.instructions[insn_idx];

            // For MoveResult, look at the previous instruction
            if matches!(insn.insn_type, dexterity_ir::instructions::InsnType::MoveResult { .. }) {
                if insn_idx > 0 {
                    let prev_insn = &block.instructions[insn_idx - 1];
                    if let Some(base_name) = get_base_name_from_instruction(prev_insn, method_lookup, type_lookup, field_lookup) {
                        let score = score_name(&base_name);
                        return Some((base_name, score));
                    }
                }
            }

            // For Move from parameter register, propagate parameter name
            // This fixes the backpressureMode2 vs emitter$BackpressureMode2 issue
            if let dexterity_ir::instructions::InsnType::Move { src, .. } = &insn.insn_type {
                if let dexterity_ir::instructions::InsnArg::Register(src_reg) = src {
                    if src_reg.reg_num >= first_param_reg {
                        // Source is a parameter - try to get the parameter name
                        if let Some(names_slice) = param_names {
                            let raw_idx = (src_reg.reg_num - first_param_reg) as usize;
                            // For instance methods, first param reg is 'this' which isn't in param_names
                            // So we need to adjust the index
                            let param_idx = if is_static {
                                raw_idx
                            } else {
                                // Skip 'this' (p0) - it's not in param_names
                                if raw_idx == 0 {
                                    return None; // 'this' doesn't have a name in param_names
                                }
                                raw_idx - 1
                            };
                            if let Some(param_name) = names_slice.get(param_idx) {
                                return Some((param_name.clone(), 90)); // High priority for param names
                            }
                        }
                    }
                }
            }

            if let Some(base_name) = get_base_name_from_instruction(insn, method_lookup, type_lookup, field_lookup) {
                let score = score_name(&base_name);
                return Some((base_name, score));
            }
        }

        // Priority 3: Type-based name (score depends on type quality)
        if let Some(arg_type) = type_info.types.get(&(reg, version)) {
            let base = VarNaming::base_name_for_type(arg_type);
            // Give Unknown types a much lower score so known types always win in groups
            // This prevents "obj" from winning over "str", "list", etc. when PHI nodes
            // connect variables with different type inference quality
            let score = if matches!(arg_type,
                ArgType::Unknown | ArgType::UnknownNarrow | ArgType::UnknownWide |
                ArgType::UnknownObject | ArgType::UnknownArray | ArgType::UnknownIntegral
            ) {
                5  // Low score for unknown types
            } else {
                40  // Normal score for known types
            };
            return Some((base.to_string(), score));
        }

        None
    };

    // For each CodeVar group, find the best BASE name across all members
    // CRITICAL: Sort keys for deterministic ordering across runs
    let mut code_var_keys: Vec<usize> = code_var_members.keys().cloned().collect();
    code_var_keys.sort();
    for code_var_idx in code_var_keys {
        let members = code_var_members.get(&code_var_idx).unwrap();
        let mut best_name: Option<String> = None;
        let mut best_score: u32 = 0;

        // Collect name candidates from all members (returns BASE names, not unique)
        for &(reg, version) in members {
            if let Some((base_name, score)) = get_name_candidate_base(reg, version, ssa, &assignment_map) {
                if score > best_score {
                    best_score = score;
                    best_name = Some(base_name);
                }
            }
        }

        // Use the best name for the entire group (make unique ONCE here)
        if let Some(base_name) = best_name {
            let unique_name = naming.make_unique(&base_name);
            code_var_names.insert(code_var_idx, unique_name);
        }
    }

    // Assign names (following JADX's guessName and makeNameForSSAVar logic)
    for (reg, version) in vars_to_name {
        // Check if this variable belongs to a CodeVar group that already has a name
        // (PHI-connected variables share the same name like JADX's CodeVar)
        if let Some(&code_var_idx) = code_var_map.get(&(reg, version)) {
            if let Some(existing_name) = code_var_names.get(&code_var_idx) {
                names.insert((reg, version), existing_name.clone());
                continue;
            }
        }

        // Get instruction offset for debug info lookup
        let insn_offset = assignment_map.get(&(reg, version)).map(|&(_, _, off)| off).unwrap_or(0);

        // Priority 1: Debug info name (like JADX's DebugInfoApplyVisitor)
        let debug_name = get_debug_name(debug_info, reg, insn_offset);

        // Priority 2: Context-based BASE name from assignment instruction
        // IMPORTANT: Get base name here, NOT unique name. We call make_unique once at the end.
        let context_base_name = if debug_name.is_none() {
            assignment_map.get(&(reg, version))
                .and_then(|&(block_idx, insn_idx, _)| {
                    let block = &ssa.blocks[block_idx];
                    let insn = &block.instructions[insn_idx];

                    // For MoveResult, look at the previous instruction (should be Invoke)
                    if matches!(insn.insn_type, dexterity_ir::instructions::InsnType::MoveResult { .. }) {
                        if insn_idx > 0 {
                            let prev_insn = &block.instructions[insn_idx - 1];
                            // Get base name from the preceding Invoke instruction
                            if let Some(base) = get_base_name_from_instruction(prev_insn, method_lookup, type_lookup, field_lookup) {
                                return Some(base);
                            }
                        }
                    }

                    // For Move from parameter register, propagate parameter name
                    if let dexterity_ir::instructions::InsnType::Move { src, .. } = &insn.insn_type {
                        if let dexterity_ir::instructions::InsnArg::Register(src_reg) = src {
                            if src_reg.reg_num >= first_param_reg {
                                if let Some(names_slice) = param_names {
                                    let param_idx = (src_reg.reg_num - first_param_reg) as usize;
                                    if let Some(param_name) = names_slice.get(param_idx) {
                                        return Some(param_name.clone());
                                    }
                                }
                            }
                        }
                    }

                    get_base_name_from_instruction(insn, method_lookup, type_lookup, field_lookup)
                })
        } else {
            None
        };

        // Now make the name unique - exactly ONE call to make_unique per variable
        let name = if let Some(name) = debug_name {
            // Got name from debug info (highest priority)
            naming.make_unique(&name)
        } else if let Some(base_name) = context_base_name {
            // Got a base name from instruction context - make it unique now
            naming.make_unique(&base_name)
        } else if let Some(arg_type) = type_info.types.get(&(reg, version)) {
            // Fall back to type-based naming (like JADX's makeNameForType)
            naming.name_for_type(arg_type)
        } else {
            // Last resort: use descriptive fallback name
            naming.make_unique("obj")
        };

        // If this variable belongs to a CodeVar group, save the name for other members
        if let Some(&code_var_idx) = code_var_map.get(&(reg, version)) {
            code_var_names.insert(code_var_idx, name.clone());
        }

        names.insert((reg, version), name);
    }

    VarNamingResult { names }
}

/// Score a variable name based on quality
/// Higher scores = better names
fn score_name(name: &str) -> u32 {
    // Penalize register-like names (r0, v1, v123, etc.) - very low priority
    if name.len() >= 2
        && (name.starts_with('r') || name.starts_with('v'))
        && name[1..].chars().all(|c| c.is_ascii_digit())
    {
        return 5;
    }

    // Penalize very short names (likely cryptic)
    if name.len() <= 1 {
        return 10;
    }
    if name.len() == 2 {
        return 20;
    }

    // Penalize names ending with many digits (i23, str12, etc.)
    let trailing_digits: usize = name.chars().rev().take_while(|c| c.is_ascii_digit()).count();
    if trailing_digits >= 2 {
        return 30;
    }
    if trailing_digits == 1 {
        return 50;
    }

    // Prefer longer, more descriptive names
    let base_score: u32 = 60;
    let length_bonus: u32 = std::cmp::min(name.len() as u32, 20);

    // Prefer camelCase names (typical Java style)
    let camel_case_bonus: u32 = if name.chars().any(|c| c.is_uppercase()) { 5 } else { 0 };

    base_score + length_bonus + camel_case_bonus
}

/// Get base name from instruction context without making it unique
/// This is a static function that doesn't consume names from the VarNaming pool.
/// Returns the base name (e.g., "length", "str", "user") that should later be made unique.
fn get_base_name_from_instruction<'a>(
    insn: &dexterity_ir::instructions::InsnNode,
    method_lookup: Option<&'a dyn Fn(u32) -> Option<MethodNameInfo>>,
    type_lookup: Option<&'a dyn Fn(u32) -> Option<String>>,
    field_lookup: Option<&'a dyn Fn(u32) -> Option<FieldNameInfo>>,
) -> Option<String> {
    use dexterity_ir::instructions::{InsnType, CastType};

    match &insn.insn_type {
        // Array length
        InsnType::ArrayLength { .. } => Some("length".to_string()),

        // String constant
        InsnType::ConstString { .. } => Some("str".to_string()),

        // Method invocation - extract name from method name
        // First check special methods (getInstance, iterator, etc.) then prefix stripping
        InsnType::Invoke { method_idx, .. } => {
            if let Some(lookup) = method_lookup {
                if let Some(info) = lookup(*method_idx) {
                    // First check special method cases
                    if let Some(special) = VarNaming::extract_name_from_method_special(&info.method_name, Some(&info.class_name)) {
                        return Some(special);
                    }
                    // Then try prefix stripping (getUser -> user)
                    if let Some(base) = VarNaming::extract_name_from_method(&info.method_name) {
                        return Some(base);
                    }
                }
            }
            None
        }

        // NewInstance - use class name for variable name
        InsnType::NewInstance { type_idx, .. } => {
            if let Some(lookup) = type_lookup {
                if let Some(type_name) = lookup(*type_idx) {
                    let base = VarNaming::extract_class_name_base(&type_name);
                    return Some(base.to_string());
                }
            }
            None
        }

        // Instance field get
        // Allow single-character field names (e.g., this.w, this.H) since they may be
        // inlined as field accesses and the name helps with type inference
        // Note: Add "2" suffix to avoid collision with actual field name
        InsnType::InstanceGet { field_idx, .. } => {
            if let Some(lookup) = field_lookup {
                if let Some(info) = lookup(*field_idx) {
                    let base = VarNaming::sanitize_field_name(&info.field_name);
                    if !base.is_empty() {
                        return Some(format!("{}2", base));
                    }
                }
            }
            None
        }

        // Static field get
        // Allow single-character field names (e.g., X.A, Foo.B) for consistency
        // Note: Add "2" suffix to avoid collision with actual field name
        InsnType::StaticGet { field_idx, .. } => {
            if let Some(lookup) = field_lookup {
                if let Some(info) = lookup(*field_idx) {
                    let base = VarNaming::sanitize_field_name(&info.field_name);
                    if !base.is_empty() {
                        return Some(format!("{}2", base));
                    }
                }
            }
            None
        }

        // CheckCast - use target type
        InsnType::CheckCast { type_idx, .. } => {
            if let Some(lookup) = type_lookup {
                if let Some(type_name) = lookup(*type_idx) {
                    let base = VarNaming::extract_class_name_base(&type_name);
                    return Some(base.to_string());
                }
            }
            None
        }

        // Primitive Cast
        InsnType::Cast { cast_type, .. } => {
            let base = match cast_type {
                CastType::IntToLong | CastType::FloatToLong | CastType::DoubleToLong => "l",
                CastType::IntToFloat | CastType::LongToFloat | CastType::DoubleToFloat => "f",
                CastType::IntToDouble | CastType::LongToDouble | CastType::FloatToDouble => "d",
                CastType::LongToInt | CastType::FloatToInt | CastType::DoubleToInt => "i",
                CastType::IntToByte => "b",
                CastType::IntToChar => "c",
                CastType::IntToShort => "s",
            };
            Some(base.to_string())
        }

        // NewArray
        InsnType::NewArray { type_idx, .. } => {
            if let Some(lookup) = type_lookup {
                if let Some(type_name) = lookup(*type_idx) {
                    if let Some(base) = VarNaming::array_var_name_from_type(&type_name) {
                        return Some(base.to_string());
                    }
                }
            }
            Some("arr".to_string())
        }

        // FilledNewArray
        InsnType::FilledNewArray { type_idx, .. } => {
            if let Some(lookup) = type_lookup {
                if let Some(type_name) = lookup(*type_idx) {
                    if let Some(base) = VarNaming::array_var_name_from_type(&type_name) {
                        return Some(base.to_string());
                    }
                }
            }
            Some("arr".to_string())
        }

        // InstanceOf
        InsnType::InstanceOf { .. } => Some("z".to_string()),

        // Compare
        InsnType::Compare { .. } => Some("cmp".to_string()),

        _ => None,
    }
}

/// Get the destination register from an instruction type
fn get_insn_dest(insn: &dexterity_ir::instructions::InsnType) -> Option<(u16, u32)> {
    use dexterity_ir::instructions::InsnType;

    match insn {
        InsnType::Const { dest, .. }
        | InsnType::ConstString { dest, .. }
        | InsnType::ConstClass { dest, .. }
        | InsnType::Move { dest, .. }
        | InsnType::MoveResult { dest }
        | InsnType::MoveException { dest }
        | InsnType::NewInstance { dest, .. }
        | InsnType::NewArray { dest, .. }
        | InsnType::ArrayLength { dest, .. }
        | InsnType::ArrayGet { dest, .. }
        | InsnType::InstanceOf { dest, .. }
        | InsnType::InstanceGet { dest, .. }
        | InsnType::StaticGet { dest, .. }
        | InsnType::Unary { dest, .. }
        | InsnType::Binary { dest, .. }
        | InsnType::Cast { dest, .. }
        | InsnType::Compare { dest, .. }
        | InsnType::Phi { dest, .. } => Some((dest.reg_num, dest.ssa_version)),

        InsnType::FilledNewArray { dest, .. } => {
            dest.as_ref().map(|d| (d.reg_num, d.ssa_version))
        }

        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_unique_names() {
        let mut naming = VarNaming::new(10);

        let name1 = naming.name_for_type(&ArgType::Int);
        let name2 = naming.name_for_type(&ArgType::Int);
        let name3 = naming.name_for_type(&ArgType::Int);

        assert_eq!(name1, "i");
        assert_eq!(name2, "i2");
        assert_eq!(name3, "i3");
    }

    #[test]
    fn test_type_names() {
        let mut naming = VarNaming::new(10);

        assert_eq!(naming.name_for_type(&ArgType::Boolean), "z");
        assert_eq!(naming.name_for_type(&ArgType::Long), "l"); // Fixed: was "j", now "l"
        assert_eq!(
            naming.name_for_type(&ArgType::Object("java/lang/String".to_string())),
            "str"
        );
        assert_eq!(
            naming.name_for_type(&ArgType::Array(Box::new(ArgType::Int))),
            "iArr"
        );
        assert_eq!(
            naming.name_for_type(&ArgType::Array(Box::new(ArgType::Long))),
            "lArr" // Fixed: was "jArr", now "lArr"
        );
    }

    #[test]
    fn test_obj_alias_mappings() {
        // Test base name mappings (each gets a fresh naming context)
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/Class".to_string())),
            "cls"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/Throwable".to_string())),
            "th"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/Exception".to_string())),
            "exc"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/Integer".to_string())),
            "num"
        );
        // JADX OBJ_ALIAS: Long → "l", Double → "d" (not "num")
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/Long".to_string())),
            "l"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/Double".to_string())),
            "d"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/Boolean".to_string())),
            "bool"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/StringBuilder".to_string())),
            "sb"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("java/lang/StringBuffer".to_string())),
            "sb"
        );
    }

    #[test]
    fn test_obj_alias_uniqueness() {
        let mut naming = VarNaming::new(10);

        // When multiple variables have the same base type, they get numeric suffixes
        let th1 = naming.name_for_type(&ArgType::Object("java/lang/Throwable".to_string()));
        let th2 = naming.name_for_type(&ArgType::Object("java/lang/Throwable".to_string()));
        let num1 = naming.name_for_type(&ArgType::Object("java/lang/Integer".to_string()));
        let num2 = naming.name_for_type(&ArgType::Object("java/lang/Integer".to_string()));

        assert_eq!(th1, "th");
        assert_eq!(th2, "th2"); // Second same-type gets numeric suffix
        assert_eq!(num1, "num");
        assert_eq!(num2, "num2"); // Second same-type gets numeric suffix

        // JADX OBJ_ALIAS: Error is NOT in OBJ_ALIAS, so it gets class name "error"
        let error = naming.name_for_type(&ArgType::Object("java/lang/Error".to_string()));
        assert_eq!(error, "error");

        // JADX OBJ_ALIAS: Long → "l", separate from Integer's "num"
        let l1 = naming.name_for_type(&ArgType::Object("java/lang/Long".to_string()));
        assert_eq!(l1, "l");
    }

    #[test]
    fn test_android_type_aliases() {
        // Test Android-specific type mappings
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("android/content/Context".to_string())),
            "context"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("android/content/Intent".to_string())),
            "intent"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("android/os/Bundle".to_string())),
            "bundle"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("android/os/Handler".to_string())),
            "handler"
        );
    }

    #[test]
    fn test_class_name_extraction() {
        // Test base name extraction for various class names
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("android/view/View".to_string())),
            "view"
        );
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("android/app/Activity".to_string())),
            "activity"
        );

        // Inner classes
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("com/example/Outer$Inner".to_string())),
            "inner"
        );

        // All-uppercase names
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("com/example/ABC".to_string())),
            "abc"
        );

        // Short names get "Var" suffix
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("com/example/AB".to_string())),
            "abVar"
        );

        // Complex inner class paths
        assert_eq!(
            VarNaming::base_name_for_type(&ArgType::Object("com/example/Outer$Middle$Inner".to_string())),
            "inner"
        );
    }

    #[test]
    fn test_mark_used() {
        let mut naming = VarNaming::new(10);
        naming.mark_used("i");

        // "i" is taken, so we should get "i2"
        let name = naming.name_for_type(&ArgType::Int);
        assert_eq!(name, "i2");
    }

    #[test]
    fn test_extract_name_from_method() {
        // Test getter methods
        assert_eq!(VarNaming::extract_name_from_method("getUser"), Some("user".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("getUserName"), Some("userName".to_string()));

        // Test setter methods
        assert_eq!(VarNaming::extract_name_from_method("setName"), Some("name".to_string()));

        // Test "is" prefix (boolean getters)
        assert_eq!(VarNaming::extract_name_from_method("isActive"), Some("active".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("isEnabled"), Some("enabled".to_string()));

        // Test "has" prefix
        assert_eq!(VarNaming::extract_name_from_method("hasPermission"), Some("permission".to_string()));

        // Test "create" prefix
        assert_eq!(VarNaming::extract_name_from_method("createBuilder"), Some("builder".to_string()));

        // Test "to" prefix
        assert_eq!(VarNaming::extract_name_from_method("toString"), Some("string".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("toArray"), Some("array".to_string()));

        // Test methods that shouldn't match
        assert_eq!(VarNaming::extract_name_from_method("getName"), Some("name".to_string()));

        // Test constructors (should not match)
        assert_eq!(VarNaming::extract_name_from_method("<init>"), None);
        assert_eq!(VarNaming::extract_name_from_method("<clinit>"), None);

        // Test new prefixes added: find, load, parse, read, compute
        assert_eq!(VarNaming::extract_name_from_method("findUser"), Some("user".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("loadData"), Some("data".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("parseJson"), Some("json".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("readValue"), Some("value".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("computeHash"), Some("hash".to_string()));

        // Test descriptive method names (4+ chars, lowercase start) - now captured
        assert_eq!(VarNaming::extract_name_from_method("execute"), Some("execute".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("start"), Some("start".to_string()));
        assert_eq!(VarNaming::extract_name_from_method("stop"), Some("stop".to_string()));

        // But short methods should not match
        assert_eq!(VarNaming::extract_name_from_method("run"), None);
        assert_eq!(VarNaming::extract_name_from_method("foo"), None);

        // Test short names
        assert_eq!(VarNaming::extract_name_from_method("getId"), Some("id".to_string())); // "id" is 2 chars, valid
        assert_eq!(VarNaming::extract_name_from_method("getX"), None); // "x" too short (1 char)

        // Test non-camelCase (should not match)
        assert_eq!(VarNaming::extract_name_from_method("getuser"), None); // lowercase after prefix
    }

    #[test]
    fn test_make_type_method_name() {
        // Basic combination: Pattern.compile() -> "patternCompile"
        assert_eq!(
            VarNaming::make_type_method_name("java/util/regex/Pattern", "compile"),
            Some("patternCompile".to_string())
        );

        // Foo.bar() -> "fooBar"
        assert_eq!(
            VarNaming::make_type_method_name("com/example/Foo", "bar"),
            Some("fooBar".to_string())
        );

        // Inner class: Outer$Inner.doSomething() -> "innerDoSomething"
        assert_eq!(
            VarNaming::make_type_method_name("com/example/Outer$Inner", "doSomething"),
            Some("innerDoSomething".to_string())
        );

        // Skip constructors
        assert_eq!(VarNaming::make_type_method_name("Foo", "<init>"), None);
        assert_eq!(VarNaming::make_type_method_name("Foo", "<clinit>"), None);

        // Skip synthetic methods
        assert_eq!(VarNaming::make_type_method_name("Foo", "$lambda"), None);
        assert_eq!(VarNaming::make_type_method_name("Foo", "access$000"), None);

        // Skip very short method names
        assert_eq!(VarNaming::make_type_method_name("Foo", "ab"), None);
    }

    #[test]
    fn test_sanitize_field_name() {
        // Normal field names should be preserved with lowercase first char
        assert_eq!(VarNaming::sanitize_field_name("buffer"), "buffer");
        assert_eq!(VarNaming::sanitize_field_name("Name"), "name");
        assert_eq!(VarNaming::sanitize_field_name("mBuffer"), "mBuffer");
        assert_eq!(VarNaming::sanitize_field_name("MAX_SIZE"), "mAX_SIZE");

        // Short/obfuscated names should return empty
        assert_eq!(VarNaming::sanitize_field_name("a"), "");
        assert_eq!(VarNaming::sanitize_field_name("b"), "");
        assert_eq!(VarNaming::sanitize_field_name("a1"), "");

        // Two-char names with uppercase OK
        assert_eq!(VarNaming::sanitize_field_name("ID"), "iD");
    }

    #[test]
    fn test_array_var_name_from_type() {
        // Descriptor format
        assert_eq!(VarNaming::array_var_name_from_type("[B"), Some("bArr"));
        assert_eq!(VarNaming::array_var_name_from_type("[I"), Some("iArr"));
        assert_eq!(VarNaming::array_var_name_from_type("[J"), Some("lArr"));
        assert_eq!(VarNaming::array_var_name_from_type("[Ljava/lang/String;"), Some("strArr"));
        assert_eq!(VarNaming::array_var_name_from_type("[Ljava/lang/Object;"), Some("arr"));

        // Java format
        assert_eq!(VarNaming::array_var_name_from_type("byte[]"), Some("bArr"));
        assert_eq!(VarNaming::array_var_name_from_type("int[]"), Some("iArr"));
        assert_eq!(VarNaming::array_var_name_from_type("String[]"), Some("strArr"));
        assert_eq!(VarNaming::array_var_name_from_type("Object[]"), Some("arr"));

        // Non-array types
        assert_eq!(VarNaming::array_var_name_from_type("int"), None);
        assert_eq!(VarNaming::array_var_name_from_type("java/lang/String"), None);
    }

    #[test]
    fn test_score_name() {
        // Very short names get low scores
        assert!(score_name("i") < score_name("index"));
        assert!(score_name("s") < score_name("str"));

        // Register-like names get very low scores
        assert!(score_name("r0") < score_name("buffer"));  // r0=5 < buffer=66
        assert!(score_name("v1") < score_name("value"));   // v1=5 < value=65

        // Names with trailing digits get penalized
        assert!(score_name("str2") < score_name("str"));   // single digit penalty
        assert!(score_name("str23") < score_name("str2")); // multi-digit penalty worse

        // Descriptive names get high scores
        assert!(score_name("buffer") > score_name("b"));
        assert!(score_name("userName") > score_name("user"));
        assert!(score_name("completableSourceArr") > score_name("arr"));

        // Verify register names are penalized
        assert_eq!(score_name("r0"), 5);
        assert_eq!(score_name("v123"), 5);
    }

    #[test]
    fn test_anonymous_class_names() {
        // Test that anonymous inner classes (numbers like $1, $2) generate "anon" not "1Var"
        // Use class names that don't match any predefined patterns
        let mut naming = VarNaming::new(10);

        // Single digit anonymous inner class - use a name that won't match common patterns
        let name1 = naming.name_for_type(&ArgType::Object("com/example/Foobar$1".to_string()));
        assert_eq!(name1, "anon", "Failed: {} doesn't match anon", name1);
        assert!(is_valid_identifier(&name1));

        // Verify multi-digit
        let name2 = naming.name_for_type(&ArgType::Object("com/example/Bazbar$123".to_string()));
        assert_eq!(name2, "anon2");
        assert!(is_valid_identifier(&name2));

        // Verify they don't start with digits
        assert!(!name1.chars().next().unwrap().is_ascii_digit());
        assert!(!name2.chars().next().unwrap().is_ascii_digit());
    }

    #[test]
    fn test_normal_numbered_classes_still_work() {
        // Ensure classes like "Foobar1" (not all-digits) still work normally
        let mut naming = VarNaming::new(10);

        // Foobar1 should NOT become "anon" since it has letters mixed with digits
        let name = naming.name_for_type(&ArgType::Object("com/example/Foobar1".to_string()));
        assert_eq!(name, "foobar1");
        assert!(is_valid_identifier(&name));
    }

    #[test]
    fn test_inner_class_reserved_names() {
        // Test that inner class short names are reserved to prevent variable-class collisions
        // This matches JADX's NameGen.addNamesUsedInClass() behavior

        // When inner class names are provided, they should be reserved
        let inner_class_names = vec![
            "Builder".to_string(),
            "Handler".to_string(),
            "Factory".to_string(),
        ];

        let naming = VarNaming::with_lookups(
            10,
            None,
            None,
            None,
            Some(&inner_class_names),
        );

        // "builder" should be reserved (lowercase version of "Builder")
        assert!(naming.used_names.contains("builder"), "builder should be reserved");
        assert!(naming.used_names.contains("handler"), "handler should be reserved");
        assert!(naming.used_names.contains("factory"), "factory should be reserved");

        // When we try to name a variable, it should get a suffix
        let mut naming = VarNaming::with_lookups(
            10,
            None,
            None,
            None,
            Some(&inner_class_names),
        );

        // A StringBuilder type would normally get "sb", not affected
        let sb_name = naming.name_for_type(&ArgType::Object("java/lang/StringBuilder".to_string()));
        assert_eq!(sb_name, "sb");

        // But a Builder type should get "builder2" since "builder" is reserved
        let builder_name = naming.name_for_type(&ArgType::Object("com/example/Builder".to_string()));
        assert_eq!(builder_name, "builder2", "Should be builder2 since builder is reserved");
    }

    #[test]
    fn test_inner_class_reserved_names_empty() {
        // Test with no inner class names - should still reserve root package names
        let naming = VarNaming::with_lookups(
            10,
            None,
            None,
            None,
            None,
        );

        // Root package names should be reserved by default (JADX parity)
        assert!(naming.used_names.contains("java"), "java should be reserved");
        assert!(naming.used_names.contains("android"), "android should be reserved");
        assert!(naming.used_names.contains("com"), "com should be reserved");
        assert!(naming.used_names.contains("org"), "org should be reserved");
        assert!(naming.used_names.contains("kotlin"), "kotlin should be reserved");
    }

    #[test]
    fn test_root_package_names_reserved() {
        // Test that root package names get numeric suffixes
        let mut naming = VarNaming::with_lookups(
            10,
            None,
            None,
            None,
            None,
        );

        // Try to name a variable "com" - should get "com2" since "com" is reserved
        let name = naming.make_unique("com");
        assert_eq!(name, "com2", "Should be com2 since com is reserved for package names");

        // Similarly for other root packages
        let mut naming2 = VarNaming::with_lookups(10, None, None, None, None);
        let java_name = naming2.make_unique("java");
        assert_eq!(java_name, "java2", "Should be java2 since java is reserved");
    }

    #[test]
    fn test_sanitize_identifier() {
        // Valid identifiers should pass through unchanged
        assert_eq!(sanitize_identifier("validName"), Some("validName".to_string()));
        assert_eq!(sanitize_identifier("_underscore"), Some("_underscore".to_string()));
        assert_eq!(sanitize_identifier("$dollar"), Some("$dollar".to_string()));

        // Hyphens should be converted to camelCase
        assert_eq!(sanitize_identifier("constructor-impl"), Some("constructorImpl".to_string()));
        assert_eq!(sanitize_identifier("padding-3ABfNKs"), Some("padding3ABfNKs".to_string()));
        assert_eq!(sanitize_identifier("lambda-5$app_debug"), Some("lambda5$app_debug".to_string()));

        // Leading digits should get underscore prefix
        assert_eq!(sanitize_identifier("3value"), Some("_3value".to_string()));

        // Empty and all-invalid should return None
        assert_eq!(sanitize_identifier(""), None);
        assert_eq!(sanitize_identifier("---"), None);

        // Reserved words after sanitization should get underscore prefix
        assert_eq!(sanitize_identifier("class"), Some("_class".to_string()));
        assert_eq!(sanitize_identifier("int"), Some("_int".to_string()));

        // Multiple hyphens
        assert_eq!(sanitize_identifier("a-b-c"), Some("aBC".to_string()));

        // Hyphen at start
        assert_eq!(sanitize_identifier("-leading"), Some("Leading".to_string()));
    }

    #[test]
    fn test_sanitize_identifier_kotlin_synthetic() {
        // Real-world Kotlin synthetic name examples
        assert_eq!(sanitize_identifier("get-impl"), Some("getImpl".to_string()));
        assert_eq!(sanitize_identifier("set-impl"), Some("setImpl".to_string()));
        assert_eq!(sanitize_identifier("box-impl"), Some("boxImpl".to_string()));
        assert_eq!(sanitize_identifier("unbox-impl"), Some("unboxImpl".to_string()));

        // Inline class bridge methods
        assert_eq!(sanitize_identifier("equals-impl"), Some("equalsImpl".to_string()));
        assert_eq!(sanitize_identifier("hashCode-impl"), Some("hashCodeImpl".to_string()));
        assert_eq!(sanitize_identifier("toString-impl"), Some("toStringImpl".to_string()));
    }

    #[test]
    fn test_types_compatible_for_naming() {
        // Same types are compatible
        assert!(types_compatible_for_naming(&ArgType::Int, &ArgType::Int));
        assert!(types_compatible_for_naming(&ArgType::Boolean, &ArgType::Boolean));
        assert!(types_compatible_for_naming(
            &ArgType::Object("java/lang/String".to_string()),
            &ArgType::Object("java/lang/String".to_string())
        ));

        // Different primitives are NOT compatible
        assert!(!types_compatible_for_naming(&ArgType::Int, &ArgType::Boolean));
        assert!(!types_compatible_for_naming(&ArgType::Int, &ArgType::Long));
        assert!(!types_compatible_for_naming(&ArgType::Float, &ArgType::Double));
        assert!(!types_compatible_for_naming(&ArgType::Char, &ArgType::Short));

        // Primitives and objects are NOT compatible
        assert!(!types_compatible_for_naming(
            &ArgType::Int,
            &ArgType::Object("java/lang/String".to_string())
        ));
        assert!(!types_compatible_for_naming(
            &ArgType::Boolean,
            &ArgType::Object("java/lang/Boolean".to_string())
        ));

        // FIX (NEW-004): Different object types are NOT compatible for naming
        // String and Integer must have separate variable names to prevent type confusion
        // (e.g., String source = "x"; source = obj.getSource(); where getSource returns AccessibilityNodeInfo)
        assert!(!types_compatible_for_naming(
            &ArgType::Object("java/lang/String".to_string()),
            &ArgType::Object("java/lang/Integer".to_string())
        ));

        // Arrays and non-array objects are NOT compatible for naming
        // (commit 3cc55ee8d fixed this - String and String[] must have different names)
        assert!(!types_compatible_for_naming(
            &ArgType::Array(Box::new(ArgType::Int)),
            &ArgType::Object("java/lang/Object".to_string())
        ));

        // Unknown types are NOT compatible with concrete types (conservative for naming)
        // This prevents bugs like StringBuilder obj6 = ...; obj6 = 1;
        assert!(!types_compatible_for_naming(&ArgType::Unknown, &ArgType::Int));
        assert!(!types_compatible_for_naming(&ArgType::Unknown, &ArgType::Boolean));
        assert!(!types_compatible_for_naming(
            &ArgType::Unknown,
            &ArgType::Object("java/lang/String".to_string())
        ));
        assert!(!types_compatible_for_naming(&ArgType::Int, &ArgType::Unknown));

        // But Unknown types are compatible with each other
        assert!(types_compatible_for_naming(&ArgType::Unknown, &ArgType::Unknown));
        assert!(types_compatible_for_naming(&ArgType::Unknown, &ArgType::UnknownNarrow));
        assert!(types_compatible_for_naming(&ArgType::UnknownObject, &ArgType::UnknownArray));

        // UnknownObject is compatible with Object types
        assert!(types_compatible_for_naming(
            &ArgType::UnknownObject,
            &ArgType::Object("java/lang/String".to_string())
        ));

        // UnknownNarrow is compatible with narrow primitives
        assert!(types_compatible_for_naming(&ArgType::UnknownNarrow, &ArgType::Int));
        assert!(types_compatible_for_naming(&ArgType::UnknownIntegral, &ArgType::Int));

        // But UnknownNarrow is NOT compatible with Object types (the key fix!)
        assert!(!types_compatible_for_naming(
            &ArgType::UnknownNarrow,
            &ArgType::Object("java/lang/StringBuilder".to_string())
        ));
    }
}
