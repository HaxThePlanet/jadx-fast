package com.google.firebase.firestore.local;

import com.google.firebase.firestore.model.BasePath;
import com.google.firebase.firestore.model.FieldPath;
import com.google.firebase.firestore.model.ResourcePath;
import com.google.firebase.firestore.util.Assert;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/* loaded from: classes2.dex */
final class EncodedPath {

    private static final char ENCODED_ESCAPE = '\u0011';
    private static final char ENCODED_NUL = '\u0010';
    private static final char ENCODED_SEPARATOR = '\u0001';
    private static final char ESCAPE = '\u0001';
    private static List<String> decode(String string) {
        char charAt2;
        int i3;
        int i5;
        int i4;
        String substring;
        int indexOf;
        String length;
        String str;
        int i;
        char charAt;
        int i2;
        int length2 = string.length();
        int i6 = 2;
        final int i7 = 0;
        final int i8 = 1;
        i5 = length2 >= i6 ? i8 : i7;
        Object[] arr2 = new Object[i8];
        arr2[i7] = string;
        Assert.hardAssert(i5, "Invalid path \"%s\"", arr2);
        if (length2 == i6) {
            if (string.charAt(i7) == i8 && string.charAt(i8) == i8) {
                i3 = string.charAt(i8) == i8 ? i8 : i7;
            } else {
            }
            Object[] arr = new Object[i8];
            arr[i7] = string;
            Assert.hardAssert(i3, "Non-empty path \"%s\" had length 2", arr);
            return Collections.emptyList();
        }
        ArrayList arrayList = new ArrayList();
        StringBuilder stringBuilder3 = new StringBuilder();
        i4 = i7;
        while (i4 < length2) {
            indexOf = string.indexOf(i8, i4);
            length = "\"";
            str = "Invalid encoded resource path: \"";
            i = indexOf + 1;
            charAt = string.charAt(i);
            if (stringBuilder3.length() == 0) {
            } else {
            }
            stringBuilder3.append(string.substring(i4, indexOf));
            substring = stringBuilder3.toString();
            stringBuilder3.setLength(i7);
            arrayList.add(substring);
            i4 = indexOf + 2;
            stringBuilder3.append(string.substring(i4, indexOf));
            stringBuilder3.append(i7);
            stringBuilder3.append(string.substring(i4, i));
        }
        return arrayList;
    }

    static FieldPath decodeFieldPath(String string) {
        return FieldPath.fromSegments(EncodedPath.decode(string));
    }

    static ResourcePath decodeResourcePath(String string) {
        return ResourcePath.fromSegments(EncodedPath.decode(string));
    }

    static <B extends BasePath<B>> String encode(B b) {
        int i;
        String segment;
        StringBuilder stringBuilder = new StringBuilder();
        i = 0;
        while (i < b.length()) {
            if (stringBuilder.length() > 0) {
            }
            EncodedPath.encodeSegment(b.getSegment(i), stringBuilder);
            i++;
            EncodedPath.encodeSeparator(stringBuilder);
        }
        EncodedPath.encodeSeparator(stringBuilder);
        return stringBuilder.toString();
    }

    private static void encodeSegment(String string, StringBuilder stringBuilder2) {
        int i;
        int charAt;
        int i2;
        i = 0;
        while (i < string.length()) {
            charAt = string.charAt(i);
            i2 = 1;
            if (charAt != 0) {
            } else {
            }
            stringBuilder2.append(i2);
            stringBuilder2.append('\u0010');
            i++;
            if (charAt != i2) {
            } else {
            }
            stringBuilder2.append(i2);
            stringBuilder2.append('\u0011');
            stringBuilder2.append(charAt);
        }
    }

    private static void encodeSeparator(StringBuilder stringBuilder) {
        final int i = 1;
        stringBuilder.append(i);
        stringBuilder.append(i);
    }

    static String prefixSuccessor(String string) {
        int i;
        StringBuilder stringBuilder = new StringBuilder(string);
        int i2 = 1;
        obj6 -= i2;
        char charAt = stringBuilder.charAt(obj6);
        int i4 = 0;
        i = charAt == i2 ? i2 : i4;
        Assert.hardAssert(i, "successor may only operate on paths generated by encode", new Object[i4]);
        stringBuilder.setCharAt(obj6, (char)i3);
        return stringBuilder.toString();
    }
}
